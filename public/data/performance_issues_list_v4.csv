Issue;Side-Effect;Category;Android-Specific;Chimera;Adoctor;DAAP;Lint;PMD;Ecoandroid;Leafactor;Paprika;Droidlens;xAL;Spotbugs;Spotbugs-fbcontrib;Infer;Detekt;Detectable in Kotlin;Explanation;Sample;Expected fix;File Extensions;Severity;Example_1;Example_2;Possible Void;Plausible Occurance Scenario;;;;;
SlowForLoop;Runtime;Suboptimal Algorithm;Yes;;✅;✅;;;;;;;;;;;;;The standard version of the for loop is slower than the for-each loop. Therefore, Android developers should always use an enhanced version of the loop to improve the efﬁciency of the app.;;Replace standard for loops with enhanced for-each loops whenever possible. This improves performance and efficiency by avoiding unnecessary index calculations and direct array manipulations.;*.java, *.kt;Warning;SlowForLoop1.txt;SlowForLoop2.txt;A standard for loop is necessary if the index of the element is required for logic beyond simply accessing the element, or if the collection needs to be modified during iteration (e.g., removing elements), which is often unsafe with an enhanced for-each loop.;A developer is processing a collection of user notifications in an Android app. The task involves iterating through an ArrayList of notification objects to filter out expired ones before displaying them to the user. The developer needs to access each element sequentially to check timestamps and update the UI accordingly;uses org.eclipse.jdt ast parser, does not supports kotlin;uses org.eclipse.jdt ast parser, does not supports kotlin;uses org.eclipse.jdt ast parser, does not supports kotlin;uses org.eclipse.jdt ast parser, does not supports kotlin;uses org.eclipse.jdt ast parser, does not supports kotlin
DrawAllocation;Runtime;Resource Management;Yes;;;;✅;;;✅;✅;✅;;;;;;✅;You should avoid allocating objects during a drawing or layout operation. These are called frequently, so a smooth UI can be interrupted by garbage collection pauses caused by the object allocations. The way this is generally handled is to allocate the needed objects up front and to reuse them for each drawing operation. Some methods allocate memory on your behalf (such as Bitmap.create), and these should be handled in the same way.;https://googlesamples.github.io/android-custom-lint-rules/checks/DrawAllocation.md.html;Avoid allocating new objects during drawing or layout operations (e.g onDraw methods). Instead, preallocate objects before drawing and reuse them. Methods like Bitmap.create() should also follow this approach to prevent frequent garbage collection and UI lag. Examples of such methods: android.view.View, android.view.ViewGroup.dispatchDraw, android.graphics.drawable.Drawable.draw, android.view.View.invalidate, android.view.View.postInvalidate, android.view.View.onDrawForeground, android.view.View.onMeasure, android.view.ViewGroup.onLayout, android.view.View.layout, android.view.View.onSizeChanged, ;*.java, *.kt;Warning;DrawAllocation1.txt;DrawAllocation2.txt;Object allocation within onDraw may be unavoidable if the object's properties depend on dynamic values that are only available during the drawing phase, making pre-allocation impossible. For very simple, short-lived objects, the complexity of caching might outweigh the negligible garbage collection overhead.;A developer is implementing a custom view that displays real-time data visualization. The onDraw() method needs to render multiple shapes and paths based on incoming sensor data. The rendering involves creating Paint objects, Rect objects, and other drawing primitives to represent the visualization elements;uses com.github.javaparser.ast, does not support kotlin;uses com.github.javaparser.ast, does not support kotlin;uses com.github.javaparser.ast, does not support kotlin;uses com.github.javaparser.ast, does not support kotlin;uses com.github.javaparser.ast, does not support kotlin
Recycle;Memory;Resource Management, API Misuse;Yes;;;;✅;;;✅;;;;;;;;✅;Many resources, such as TypedArrays, VelocityTrackers, etc., should be recycled (with a recycle() call) after use. This lint check looks for missing recycle() calls.;https://googlesamples.github.io/android-custom-lint-rules/checks/Recycle.md.html;Always call .recycle() on resources such as TypedArray, VelocityTracker, and others after use. This prevents memory leaks and ensures efficient resource management.;*.java, *.kt;Warning;Recycle1.txt;Recycle2.txt;"The object (e.g., a TypedArray) is being managed by a framework or library that takes ownership of its lifecycle. Calling recycle() manually could interfere with the framework and lead to a ""double recycle"" crash.";A developer is implementing a custom theme for UI components using TypedArray. The task involves reading custom attributes from XML styles, applying them to various views in a layout, and then handling the TypedArray resource after extracting all the needed values; com.android.tools.lint.detector.api.Detector.JavaPsiScanner does not support kotlin, but newer versions of Kotlin UAST support; com.android.tools.lint.detector.api.Detector.JavaPsiScanner does not support kotlin, but newer versions of Kotlin UAST support; com.android.tools.lint.detector.api.Detector.JavaPsiScanner does not support kotlin, but newer versions of Kotlin UAST support; com.android.tools.lint.detector.api.Detector.JavaPsiScanner does not support kotlin, but newer versions of Kotlin UAST support; com.android.tools.lint.detector.api.Detector.JavaPsiScanner does not support kotlin, but newer versions of Kotlin UAST support
WakeLock;Energy;Concurrency, Resource Management;Yes;;✅;✅;✅;;✅;✅;;;;;;;;✅;Failing to release a wakelock properly can keep the Android device in a high power mode (which reduces battery life). There are several causes of this, such as releasing the wake lock in onDestroy() instead of in onPause(), failing to call release() in all possible code paths after an acquire(), and so on.NOTE: If you are using the lock just to keep the screen on, you should strongly consider using FLAG_KEEP_SCREEN_ON instead. This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. ;https://googlesamples.github.io/android-custom-lint-rules/checks/Wakelock.md.html;Ensure wake locks are released properly in onPause() instead of onDestroy(), and always include a release() call in all possible code paths. If keeping the screen on is the only goal, use FLAG_KEEP_SCREEN_ON instead, as it is managed automatically by the platform.;*.java, *.kt;Warning;WakeLock1.txt;WakeLock2.txt;In a service with complex, interwoven asynchronous operations, it can be extremely difficult to guarantee that release() is called in every possible code path. Using a timed WakeLock might be a safer, more robust alternative to prevent a permanent lock, even if a static analyzer can't verify all release paths.;A developer is building a music player service that needs to continue playback when the screen is off. The task involves acquiring a WakeLock in the service that handles audio playback to prevent the CPU from sleeping while music is playing,;usa lint, suports kt;usa lint, suports kt;usa lint, suports kt;usa lint, suports kt;usa lint, suports kt
WakelockTimeout;Energy;Resource Management;Yes;;;;✅;;;;;;;;;;;✅;Wakelocks have two acquire methods: one with a timeout, and one without. You should generally always use the one with a timeout. A typical timeout is 10 minutes. If the task takes longer than it is critical that it happens (i.e. can't use JobScheduler) then maybe they should consider a foreground service instead (which is a stronger run guarantee and lets the user know something long/important is happening).;https://googlesamples.github.io/android-custom-lint-rules/checks/WakelockTimeout.md.html;Always use the wake lock acquire method that includes a timeout. A typical timeout is 10 minutes. If longer execution is needed, consider using a foreground service instead, which ensures the task completes while informing the user.;*.java, *.kt;Warning;WakelockTimeout1.txt;WakelockTimeout2.txt;A task may be critical and uninterruptible, but its duration is unknown (e.g., processing a user-provided file of unknown size). While a foreground service is usually recommended, it might be too intrusive for the user experience, making a non-timed WakeLock a deliberate design choice.;;;;;;
ViewHolder;Runtime;Suboptimal Algorithm, Resource Management;Yes;;;;✅;;;✅;;;;;;;;✅;When implementing a view Adapter, you should avoid unconditionally inflating a new layout. If an available item is passed in for reuse, you should try to use that one instead. This helps make for example ListView scrolling much smoother.;https://googlesamples.github.io/android-custom-lint-rules/checks/ViewHolder.md.html;: In RecyclerView.Adapter and similar adapters, reuse existing views instead of inflating new ones each time. Implement the ViewHolder pattern to improve scrolling performance and reduce unnecessary object creation.;*.java, *.kt;Warning;ViewHolder1.txt;ViewHolder2.txt;For a list with a very small and fixed number of items (e.g., 2-3), a developer might consider the implementation of the ViewHolder pattern to be unnecessary overhead, even though it remains a recommended practice.;A developer is creating a scrollable feed of social media posts using a RecyclerView. The task involves displaying a list of post objects to view items that display user avatars, post content, and interaction buttons as the user scrolls through the timeline.;supports kotlin but offers lacks rule for performance ;supports kotlin but offers lacks rule for performance ;supports kotlin but offers lacks rule for performance ;supports kotlin but offers lacks rule for performance ;supports kotlin but offers lacks rule for performance 
ObsoleteLayoutParam;Runtime;Resource Management, Code Smell;Yes;;;;✅;;;✅;;;;;;;;✅;The given layout_param is not defined for the given layout, meaning it has no effect. This usually happens when you change the parent layout or move view code around without updating the layout params. This will cause useless attribute processing at runtime, and is misleading for others reading the layout so the parameter should be removed.;https://googlesamples.github.io/android-custom-lint-rules/checks/ObsoleteLayoutParam.md.html;Edit the XML file and delete the obsolete parameter that has no effect;*.xml;Warning;ObsoleteLayoutParam1.txt;ObsoleteLayoutParam2.txt;The layout parameter might appear obsolete in the static XML file but could be functional at runtime if the view is programmatically re-parented into a different layout that does recognize and use that specific parameter.;A developer is developing a UI layout and needs to use a LinearLayout. It has to align the views inside the layout(Buttons, TextViews and Images) with each other and with the parent element.;no;no;no;no;no
BLOBClass;Runtime;Code Smell;No;;;;;;;;✅;✅;;;;;;;Blob Class (BLOB) - OO: A Blob class, also know as God class, is a class with a large number of attributes and/or methods [17]. The Blob class handles a lot of responsibilities compared to other classes. Attributes and methods of this class are related to different concepts and processes, implying a very low cohesion. Blob classes are also often associated with numerous data classes. Blob classes are hard to maintain and increase the difﬁculty to modify the software. In PAPRIKA, classes are identiﬁed as Blob classes whenever the metrics numbers_of_attributes, number_of_methods and lack_of_cohesion_in_methods are very high.;; Refactor the large class by splitting it into multiple smaller, cohesive classes with clear responsibilities. Use Single Responsibility Principle (SRP) to ensure each class focuses on a single task. Extract related attributes and methods into separate, more maintainable classes.;*.java, *.kt;Warning;BLOBClass1.txt;BLOBClass2.txt;"The class might be designed as a ""Facade,"" acting as a simplified entry point to a more complex subsystem. While it aggregates many responsibilities, it delegates the actual work to smaller, more cohesive classes, making it a valid design pattern.";A developer is creating the main activity for a messaging application. The task involves handling user authentication, message composition, contact management, media attachment processing, and notification preferences all within a class that serves as the central controller for the application's functionality;;;;;
SwissArmyKnife;Runtime;Code Smell;No;;;;;;;;✅;✅;;;;;;;A Swiss army knife is a class with numerous interface signatures, resulting in a very complex class interface designed to handle a wide diversity obstractions. This type of class is hard to understand and to maintain because of the resulting complexity. A SAK is detected by Paprika when a class implements a large number of interfaces.;;Reduce the number of interfaces a class implements. If multiple interfaces are needed, consider breaking them into smaller, more specialized interfaces (Interface Segregation Principle). This makes the class easier to understand and maintain.;*.java, *.kt;Warning;SwissArmyKnife1.txt;SwissArmyKnife2.txt;In a plugin-based architecture, a central class may need to implement multiple interfaces to be discoverable and usable by different modules or plugins. Its complexity is a trade-off for architectural flexibility.;A developer is building a network utility class for an Android application. The task involves creating a component that implements multiple interfaces to handle different aspects of connectivity, including download management, caching, authentication, encryption, and error handling across the entire application;;;;;
Longmethod;Runtime;Code Smell;No;;;;;;;;✅;✅;;;;;;;Long methods are implemented with much more lines of code than other methods. They are often very complex, and thus hard to understand and main-tain. These methods can be split into smaller methodstofixtheproblem[21]. Paprika iden- tifies a long method when the number of instructions for one method is very high.;;Break long methods into multiple smaller methods, each performing a specific task. Use method extraction to improve readability and maintainability. Follow the Single Responsibility Principle (SRP) to avoid excessive complexity in a single method.;*.java, *.kt;Warning;Longmethod1.txt;Longmethod2.txt;A method implementing a complex, inherently sequential algorithm (like a detailed parser or a state machine) might be clearer as a single, long method rather than being artificially broken into smaller ones, which could obscure the overall logic.;A developer needs to implement a data synchronization feature that processes local data, compares it with server data, resolves conflicts, updates the database, and refreshes the UI. Access to this feature should be provided by a single method;;;;;
ComplexClass;Runtime;Code Smell;No;;;;;;;;✅;✅;;;;;;;A complex class is a class containing complex methods. Again, these classes are hard to understandand maintain and need to be refactored [21]. The class complexity is calculated by summing the internal methods complexities. The complexity of a method can be calculated using McCabe’s Cyclomatic Complexity [27].;;educe the internal complexity of the class by simplifying complex methods. Use Cyclomatic Complexity (McCabe's metric) as a guide to refactor methods into smaller, well-defined methods. Apply design patterns like Strategy or Factory to delegate responsibilities.;*.java, *.kt;Warning;ComplexClass1.txt;ComplexClass2.txt;A class designed to implement a complex, well-defined standard (e.g., a parser for a complex file format or a networking protocol) will have an inherently high complexity that mirrors the problem it is solving.;A developer is creating a custom camera implementation that handles camera initialization, preview rendering, photo capture, video recording, image processing, and various camera settings. The class should deal with complex decision trees, nested conditions, and multiple execution paths to handle different device capabilities and user interactions.;;;;;
InternalGetterSetter;Runtime;Obsolete Solution;No;✅;✅;✅;✅;;;;✅;✅;;;;;;NA;On Android, fields should be accessed directly within a class to increase performance. The usage of an internal getter or a setter con- verts into a virtual invoke, which makes the operation three times slower than a direct access . NOTE: As of Android 2.3 (Gingerbread), this optimization is performed automatically by Dalvik, so there is no need to change your code. this is only relevant if you are targeting older versions of Android.;;This issue is obsolete for Android versions 2.3 (Gingerbread) and above since the Dalvik runtime optimizes direct field access. If targeting very old versions, access fields directly within the class instead of using getters and setters to improve performance.;*.java, *.kt;Useless;InternalGetterSetter1.txt;InternalGetterSetter2.txt;This issue is obsolete for Android 2.3 (Gingerbread) and above, as the Dalvik and ART runtimes automatically optimize direct field access. Therefore, on any modern Android version, this warning is void.;A developer is building a data model class for a user profile that contains various attributes like name, email, and preferences. Within the class's internal methods, they access class fields.;;;;;
MemberIgnoringMethod;Runtime;Suboptimal Algorithm;No;✅;✅;✅;;;;;✅;✅;;;;;;;On Android, when a method does not access an object attribute, it is recommended to use a static method. The static method invocations are about 15%–20% faster than a dynamic invocation.;;Non-static methods that do not access any internal properties of the class should be made static in order to increase their efficiency;*.java, *.kt;Warning;MemberIgnoringMethod1.txt;MemberIgnoringMethod2.txt;The method may be part of a class hierarchy and is designed to be overridden by subclasses. While the base implementation doesn't access instance members, its overrides will, making it non-static by design.;A developer is implementing utility functions in a Java Class. One method performs string formatting for display purposes, another validates input patterns, and a third calculates statistical methods over the data provided as input ;;;;;
NoLowMemoryResolver;Memory;Resource Management;Yes;;✅;✅;;;;;✅;✅;✅;;;;;✅;When the Android system is running low on memory, the system calls the method onLowMemory() of running activities, which are supposed to trim their memory usage. If this method is not implemented by the activity, the Android system kills the process in order to free memory, and can cause an abnormal termination of programs ;;Implement the onLowMemory() and onTrimMemory(int level) methods in Activity and Application classes to handle low-memory situations. Free unnecessary resources, clear caches, and optimize memory usage to prevent unexpected app termination.;*.java, *.kt;Warning;NoLowMemoryResolver1.txt;NoLowMemoryResolver2.txt;The application may have a very small and predictable memory footprint, making it highly unlikely to trigger a low-memory situation. In such a case, implementing onLowMemory would add code complexity for a negligible benefit.; developer is creating an image gallery application that loads and caches multiple high-resolution images. The application implements Activity and Fragment lifecycle methods to load and show the gallery and individual photos;;;;;
LeakingInnerClass;Memory;Code Smell;No;;✅;✅;✅;;;;✅;✅;;✅;;;;;In Java, non-static inner and anonymous classes are holding a reference to the outer class, whereas static inner classes are not. This could provoke a memory leak in Android systems;;Convert non-static inner classes to static inner classes or use WeakReference to avoid memory leaks. If an inner class requires access to the outer class, use a WeakReference<OuterClass> instead of a direct reference.;*.java, *.kt;Warning;LeakingInnerClass1.txt;LeakingInnerClass2.txt;A leak is impossible if the inner class instance's lifecycle is guaranteed to be shorter than the outer class's lifecycle. For example, a short-lived Runnable that is created, executed, and garbage collected long before its outer Activity is destroyed.;A developer is implementing a long-running background task that processes data and needs to update the UI when complete. Inside an Activity, they need to handle the background work.;;;;;
UnsuitedLRUCacheSize;Memory;Resource Management;Yes;;;;;;;;;✅;;;;;;;in Android, a cache can be used to store frequently used objects with the Least Recently Used (LRU) API. The code smell occurs when the LRU is initialized without checking the available memory via the getMemoryClass() method. The available memory may vary considerably according to the device so it is necessary to adapt the cache size to the available memory;;When initializing an LRUCache, set its size dynamically based on available memory using ActivityManager.getMemoryClass(). This ensures the cache size adapts to different device specifications, preventing excessive memory usage.;*.java, *.kt;Warning;UnsuitedLRUCacheSize1.txt;UnsuitedLRUCacheSize2.txt;The cache may be designed to hold a small, fixed set of objects where the total memory usage is known and trivial. In this case, a dynamic size calculation based on the device's memory class is unnecessary overhead.;A developer is building a news reader application that caches article images to improve scrolling performance, which suggest the need to use an LRU cache.;;;;;
HashmapUsage;Memory;Data Manipulation, Obsolete Solution;Yes;✅;✅;✅;✅;;;;✅;✅;;;;;;✅;the usage of HashMap is inadvisable when managing small sets in Android. Using HashMaps entails the auto-boxing process where primitive types are converted into generic objects. The issue is that generic objects are much larger than primitive types, 16 and 4 bytes, respectively. Therefore, the framework recommends using the SparseArray data structure that is more memory-eﬃcient;https://googlesamples.github.io/android-custom-lint-rules/checks/UseSparseArrays.md.html;Replace HashMap<Integer, Object> with SparseArray<T>, SparseIntArray, or SparseBooleanArray when working with primitive integer keys. This avoids auto-boxing and significantly reduces memory consumption.;*.java, *.kt;Warning;HashmapUsage1.txt;HashmapUsage2.txt;The code might be part of a shared module that is not Android-specific and therefore cannot use SparseArray. Additionally, for very large and dense sets of data, the performance of HashMap can be better than SparseArray, which uses a binary search.;A developer is implementing a feature to store and retrieve configuration settings with integer keys on memory;;;;;
Overdraw;Energy;Resource Management;yes;;;;✅;;;;;;;;;;;;If you set a background drawable on a root view, then you should use a custom theme where the theme background is null. Otherwise, the theme background will be painted first, only to have your custom background completely cover it. this is called “overdraw”. NOTE: This detector relies on figuring out which layouts are associated with which activities based on scanning the Java code, and it's currently doing that using an inexact pattern matching algorithm. Therefore, it can incorrectly conclude which activity the layout is associated with and then wrongly complain that a background-theme is hidden. If you want your custom background on multiple pages, then you should consider making a custom theme with your custom background and just using that theme instead of a root element background. Of course it's possible that your custom drawable is translucent and you want it to be mixed with the background. However, you will get better performance if you pre-mix the background with your drawable and use that resulting image or color as a custom theme background instead.;;Remove unnecessary background layers in XML or Java code. If setting a custom background on a root view, use a theme with a transparent background instead of layering multiple backgrounds. Pre-mix translucent backgrounds with images for better performance.;*.xml;Warning;Overdraw1.txt;Overdraw2.txt;The background being flagged as overdraw might be a semi-transparent layer that is intentionally designed to blend with the theme's background to create a specific visual effect. The tool might not correctly detect the alpha channel and flag it as fully opaque.; A developer is designing a custom list item layout for a RecyclerView. The layout includes a root FrameLayout, a CardView and an inner LinearLayout with background color. ;;;;;
UIOverdraw;Energy;Resource Management;Yes;;;✅;✅;;;;✅;✅;;;;;;✅;a UI Overdraw is a situation where a pixel of the screen is drawn many times in the same frame. This happens when the UI design consists of unneeded overlapping layers, e.g., hidden backgrounds. To avoid such situations, the canvas.quickreject() API should be used to define the view boundaries that are drawable;;"Optimize layout design by removing overlapping UI layers. Use canvas.quickReject() to define drawable boundaries and prevent unnecessary rendering. Enable ""Show GPU Overdraw"" in Developer Options to detect excessive overdraw.";*.java, *.kt;Warning;UIOverdraw1.txt;UIOverdraw2.txt;The overlapping layers might be an intentional part of the design, used to create effects like parallax scrolling, shadows, or complex animations where some amount of overdraw is unavoidable to achieve the desired visual outcome.;A developer is creating a custom view that draws a complex visualization with multiple layers of graphics. The implementation should draw all elements for every frame.;;;;;
InvalidatewithoutRect;Runtime;Unnecessary Computation;Yes;;;;;;;;✅;✅;✅;;;;;;refers to a code smell that arises when rect to be redrawn is not specified while invalidating the view;; When calling invalidate(), specify a bounding rectangle (invalidate(Rect) or invalidate(left, top, right, bottom)) to redraw only the affected area instead of the entire view, improving performance.;*.java, *.kt;Warning;InvalidatewithoutRect1.txt;InvalidatewithoutRect2.txt;Calling invalidate() without specifying a rectangle is the correct and most efficient approach when the entire content of the view has changed, making a partial redraw insufficient.;A developer is implementing a custom view that displays real-time data visualization. When new data arrives, the view needs to be redrawn to reflect changes and evaluate when only a small section has changed.;;;;;
UnsupportedHardwareAcceleration;Runtime;Suboptimal Algorithm;Yes;;;;;;;;✅;✅;✅;;;;;;On Android, most of the drawing operations are executed in the GPU. Rare drawing operations that are executed in the CPU, e.g., drawPath method in android.graphics.Canvas, should be avoided to reduce CPU load;;Avoid CPU-bound drawing operations like Canvas.drawPath() in performance-critical areas. Instead, use hardware-accelerated alternatives like ShapeDrawable, VectorDrawable, or OpenGL ES for complex graphics.;*.java, *.kt;Warning;UnsupportedHardwareAcceleration1.txt;UnsupportedHardwareAcceleration2.txt;The specific drawing operation being used, such as a complex path effect, may not be supported by hardware acceleration on certain devices or API levels, leaving the CPU-bound version as the only viable option.;A developer is creating a custom drawing application that allows users to draw freehand paths;;;;;
HeavyAsyncTask;Runtime;Concurrency, Suboptimal Algorithm;Yes;;;;;;;;✅;✅;✅;;;;;;refers to a code smell that arises when heavy operations are carried out inside an Async Task. Heavy operation is considered to be any operation that has computational complexity of greater than 10 (McConnel S. Code Complete).;;Offload heavy computations (e.g., complex loops, large database operations) from AsyncTask.doInBackground() to background worker threads using Executors, Coroutines, or WorkManager.;*.java, *.kt;Warning;HeavyAsyncTask1.txt;HeavyAsyncTask2.txt;"The flagged ""heavy"" operation might be I/O-bound rather than CPU-bound, with multiple short waits. In such cases, the overall execution time could be well within acceptable limits for an AsyncTask, making a more complex threading solution like ExecutorService or Coroutines an over-engineering.";A developer is implementing an image processing feature that applies complex filters to photos and perform this task on the background;;;;;
HeavyServiceStart;Energy;Suboptimal Algorithm;Yes;;;;;;;;✅;✅;✅;;;;;;refers to a code smell that arises when heavy operations are carried out inside a Service;;void running long or computationally expensive tasks inside Service. Use JobScheduler, WorkManager, or foreground services for long-running operations.;*.java, *.kt;Warning;HeavyServiceStart1.txt;HeavyServiceStart2.txt;;A developer is creating a music player service that needs to load and process audio files. He should build a service that should allow to populate the app by decoding audio files, building playlists, and initializing audio effects when the service starts.;;;;;
HeavyBroadcastReceiver;Energy;Suboptimal Algorithm;Yes;;;;;;;;✅;✅;✅;;;;;;refers to a code smell that arises when heavy operations are carried out inside a onRecieve() function of Broadcast Receiver;;Keep onReceive() lightweight. Offload heavy processing to a background thread using IntentService, WorkManager, or JobIntentService. Avoid long-running computations in broadcast receivers to prevent ANRs.;*.java, *.kt;Warning;HeavyBroadcastReceiver1.txt;HeavyBroadcastReceiver2.txt;The receiver might be listening for a very infrequent but high-priority system event where immediate, synchronous processing is essential. If the work is just on the edge of the time limit, the developer might accept the risk to ensure the task is completed promptly.;A developer is implementing a broadcast receiver that responds to system events like connectivity changes. It should allow to perform network operations to check server status, update local databases, and synchronize data.;;;;;
BitmapFormatUsage;Memory;Resource Management;Yes;;;;;;;;✅;;✅(divergent);;;;;;Bitmap Format Usage is a code smell that arises when images are represented as Bitmaps which is memory intensive function.;;optimize bitmap usage by using vector drawables (VectorDrawable) or WebP format instead of Bitmap. When using bitmaps, compress them using BitmapFactory.Options.inSampleSize and avoid loading full-resolution images unnecessarily.;*.java, *.kt;Warning;BitmapFormatUsage1.txt;BitmapFormatUsage2.txt;The application may need to perform pixel-level manipulations (e.g., applying dynamic filters), which is straightforward with a Bitmap object but not possible with vector drawables or compressed formats like WebP.;A developer is building a photo gallery application that displays multiple high-resolution images. They should load images as Bitmap objects ;;;;;
UnclosedCloseable;Memory;Resource Management;Yes;;✅;✅;;;;;;;;;;✅;;✅;A class that implements the java.io.Closeable interface is supposed to invoke the close method to release resources that an object is holding.;;Always close resources (like files, streams, or database cursors) by calling close() in a finally block or using Java’s try-with-resources;*.java, *.kt;Warning;UnclosedCloseable1.txt;UnclosedCloseable2.txt;The Closeable resource (like an InputStream) may be wrapped by another object or passed to a library that explicitly takes ownership and guarantees that it will be closed, making a finally block in the original code redundant.;A developer is implementing a feature to read configuration data from a file.  A InputStream should be used to read the file contents ;;;;;
CameraLeak;Energy;Resource Management;Yes;✅;;;;;✅;;;;✅;;;;;✅;android.hardware.Camera - Keeping the camera active without using it;;Always release the camera when it is no longer needed by calling camera.release() in onPause() or onDestroy(). Consider using Camera2API, which provides a more lifecycle-aware approach.;*.java, *.kt;Warning;CameraLeak1.txt;CameraLeak2.txt;The camera's lifecycle might be managed by a higher-level component or a third-party library. A manual release call could interfere with this manager, leading to a crash. The static analysis tool may not see the release call in the managing component.;A developer is implementing a QR code scanner feature that uses the device camera. When the user navigates to the scanner screen, it should open the camera;;;;;
MediaLeak;Energy;Resource Management;Yes;✅;;;;;✅;;;;✅;;;;;✅;Keeping the media recorder active without using it;;Always stop and release the MediaRecorder when finished recording using stop() and release() methods;*.java, *.kt;Warning;MediaLeak1.txt;MediaLeak2.txt;Similar to CameraLeak, the MediaRecorder might be managed by a component that controls its lifecycle across different states (e.g., continuing to record for a short period in the background). Releasing it prematurely in onPause() would be a bug.;A developer is creating a video recording feature that uses MediaRecorder, which should enable to start and top a video recording.;;;;;
LeakingThread;Memory;Resource Management;No;;✅;✅;✅?;;;;;;✅;;;;;✅;In Android programming a thread is a garbage collector (GC) root. The GC does not collect the root bjects and, therefore, if a thread is not adequately stopped it can remain in memory for all the execution of the application, causing an abuse of the memory of the app. If an Activity starts a thread and does not stop it this is considered a design ﬂaw [18]. ADOCTOR detects this smell if a method of an Activity class starts a thread without stopping it through the stop method.;;Ensure that threads started within an Activity are properly stopped when the activity is destroyed. Use Thread.interrupt() or switch to HandlerThread, ExecutorService, or Kotlin Coroutines for better lifecycle management.;*.java, *.kt;Warning;LeakingThread1.txt;LeakingThread2.txt;The thread may be intentionally designed to run for the entire application's lifecycle, and it does not hold any reference to a short-lived component like an Activity, thus not causing a leak. It could also be a daemon thread.;A developer is implementing a background task that periodically refreshes data from a network source. He needs to create a Thread in an Activity's onCreate() method to perform this task;;;;;
LeakingHandler;Memory;Resource Management;No;;;✅?;✅;;;;;;✅;;;;;✅;Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class. In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler. Make all references to members of the outer class using the WeakReference object.;https://googlesamples.github.io/android-custom-lint-rules/checks/HandlerLeak.md.html;Declare handlers as static inner classes to prevent memory leaks. Use a WeakReference to reference the outer class;*.java, *.kt;Warning;LeakingHandler1.txt;LeakingHandler2.txt;A leak is impossible if all messages posted to the handler are guaranteed to be processed and removed from the queue before the associated Activity can be destroyed.;A developer is implementing a long-running background task that needs to update the UI periodically. He needs to create a Handler to post messages to the main thread;;;;;
DataTransmissionWithoutCompression;Energy;RPC/IPC, Suboptimal Algorithm;No;;✅;;;;✅;;;;✅;;;;;✅;The smell arises when a method transmits a ﬁle over a network infrastructure without compressing it, causing an overhead of communication [18]. ADOCTOR detects the smell if a method performs an Http request involving an instance of the class File without using a compression library such as ZLIB2 or the APACHE HTTP CLIENT3.;;Compress files before transmitting over a network using Zlib, Gzip, or Apache HttpClient to reduce bandwidth usage;*.java, *.kt;Warning;DataTransmissionWithoutCompression1.txt;DataTransmissionWithoutCompression2.txt;The data being transmitted could already be in a compressed format (e.g., a JPEG image or a ZIP file), making additional compression redundant. Alternatively, for very small files, the computational overhead of compression and decompression could be greater than the benefit of a slightly smaller payload.;A developer is building a file-sharing feature that allows users to upload large files to a server. The upload functionality should use an HttpURLConnection;;;;;
VacuousBackgroundService;Energy;Resource Management;Yes;;;;;;;;;;✅* many false positives?;;;;;✅;refers to an energy bug that arises when a service consumes resources in the background. Hence, a service should be stopped before the application goes to background in onStop method;;Stop services when the app goes into the background by calling stopSelf() in onStop(). Prefer JobScheduler, WorkManager, or Foreground Services only when necessary.;*.java, *.kt;Warning;VacuousBackgroundService1.txt;VacuousBackgroundService2.txt;The service could be a music player or a navigation service that the user expects to continue running when the app is in the background. The tool may lack the context to distinguish this from a service that was unintentionally left running.;A developer needs to create a service to perform periodic data synchronization;;;;;
LifecycleContainment;Energy;Resource Management;Yes;✅;;;;;;;;;✅;;;;;✅;refers to a code smell that arises when a listener is registered but not unregistered from activity;;Always unregister listeners in onPause() or onDestroy();*.java, *.kt;Warning;LifecycleContainment1.txt;LifecycleContainment2.txt;The listener might be registered with an application-level component (not an Activity) and is intended to be active for the entire lifecycle of the application. In this case, it should not be unregistered in onPause.;A developer is implementing location tracking in an activity. The activity should create a LocationListener when created in order to receive location updates;;;;;
EarlyResourceBinding;Energy;Resource Management;Yes;;;;;;;;;;✅;;;;;✅;refers to code smell that arises when heavy resources such as database connections, Camera, Media Player and Location Manager are initialized before they need to be used;;Delay initializing heavy resources (e.g., Camera, MediaPlayer, LocationManager, Database) until they are actually needed instead of initializing them early in onCreate().;*.java, *.kt;Warning;EarlyResourceBinding1.txt;EarlyResourceBinding2.txt;The resource (e.g., a map view or a camera preview) may be central to the screen's primary function and is needed immediately. Delaying its initialization would lead to a poor user experience with visible loading indicators, so binding it early is a deliberate choice.;A developer is creating a camera app. He should use the camera object in the main activity;;;;;
ImmortalityBug;Energy;Resource Management;Yes;;;;;;;;;;✅* (does not check for foreground service);;;;;✅;refers to an energy bug that arises when an application re-spawns when it is not opened by the user. To detect this issues, calls to start a foreground operation like activity are removed from background operations like Services;; Prevent apps from restarting unnecessarily by removing auto-restart logic in background services. Avoid using START_STICKY unless necessary and ensure proper foreground service management.;*.java, *.kt;Warning;ImmortalityBug1.txt;ImmortalityBug2.txt;"An application like an alarm clock, a critical reminder service, or a device monitoring tool is expected to restart itself if killed. Using START_STICKY to achieve this ""immortality"" is the correct and intended behavior for such apps.";A developer is implementing a background service for data syncing;;;;;
RigidAlarmManager;Energy;Suboptimal Algorithm;Yes;;✅;✅;;;;;;;;;;;;;The AlarmManager class allows to execute operations at speciﬁc moments. Obviously, an Alarm Manager-triggered operation wakes- up the phone, possibly threatening the energy and memory efﬁciency of the app. It is recommended to use the AlarmManager.setInexactRepeating method, which ensures that the system is able to bundle several updates together [18]. Therefore, a code smell is identiﬁed by our detector if a class using an instance of AlarmManager does not deﬁne the method setInexactRepeating.;;Use setInexactRepeating() instead of setRepeating() to allow Android to batch operations and reduce power usage;*.java, *.kt;Warning;RigidAlarmManager1.txt;RigidAlarmManager2.txt;"For an alarm clock or a calendar application, the alarm must fire at a precise moment. Using the inexact setInexactRepeating() would be a functional bug, making the ""rigid"" setRepeating() the correct choice.";A developer is creating a weather app that needs to update forecast data periodically. He decided to use AlarmManager;;;;;
InefficientSQLQuery;Energy;Data Access, RPC/IPC;Yes;;✅;;;;;;;;;;;;;;In Android, the use of a SQL query is discouraged as it introduces overhead, while other solutions should be preferred (e.g., using webservices) [18]. If a method deﬁnes a JDBC connection and sends an SQL query to a remote server, the smell is identiﬁed.;; Avoid direct SQL queries when possible. Prefer Room Database, SQLite with indexing, or Web services instead of raw SQL queries to minimize performance overhead.;*.java, *.kt;Warning;InefficientSQLQuery1.txt;InefficientSQLQuery2.txt;A direct, raw SQL query might be necessary to perform a very complex operation that cannot be expressed through an ORM like Room, or to achieve maximum performance by leveraging database-specific features not exposed by the abstraction layer.;A developer is implementing a feature to fetch user data from a remote database;;;;;
DebuggableRelease;Energy;Resource Management;Yes;;✅;✅;;;;;;;;;;;;;In Android, the attribute android:debuggable of the AndroidManifest ﬁle is set during the development for debugging an app. Leaving the attribute true when the app is released is a major security threat since every external app can have full access to the source code. In this case, the detector simply parses the AndroidManifest ﬁle looking for the android:debuggable properties. If it is explicitly set to true, the smell is detected.;;"Ensure android:debuggable=""false"" in the AndroidManifest.xml file for release builds.";*.xml;Warning;DebuggableRelease1.txt;DebuggableRelease2.txt;The build process might sufer transformations that make the release not debuggable.; A developer needs to submit its app to the Google Play Store after making it debuggable ;;;;;
InefficientDataFormatAndParser;Runtime;Data Access, Suboptimal Algorithm;Yes;;✅;✅;;;;;;;;;;;;;When analyzing XML or JSON ﬁles, the use of TreeParser slows down the app, and thus it should be avoided and replaced with other more efﬁcient parsers (e.g.,StreamParser) [18]. In this case, ADOCTOR identiﬁes the smell by evaluating whether a method uses the TreeParser class.;; Replace Tree-based parsers (e.g., DocumentBuilder for XML, JSONObject for JSON) with stream-based parsers (XmlPullParser, JsonReader) for better performance.;*.java, *.kt;Warning;InefficientDataFormatAndParser1.txt;InefficientDataFormatAndParser2.txt;A tree-based parser (like DOM) is necessary when the application needs to frequently access different parts of the parsed document out of order or manipulate its structure in memory. A stream-based parser is ill-suited for such tasks.;A developer need to implement a feature to parse large XML configuration files in their app.;;;;;
MemoizationChance;Runtime;Unnecessary Computation, Suboptimal Algorithm;No;✅;;;;;;;;;;;;;;;Methods that work as simple functions are good targets to exploit memoization for performance enhancement;;Implement memoization to cache function results, avoiding redundant computations;*.java, *.kt;Warning;MemoizationChance1.txt;MemoizationChance2.txt;Memoization is impractical if the function has a very large or non-discrete input space, which would cause the cache to consume an excessive amount of memory. It is also ineffective if the function is almost never called with the same arguments twice.;A developer is implementing a utility method that calculates the Fibonacci sequence for a specific position. The method uses a recursive approach that repeatedly calculates the same values for overlapping subproblems. This computation-heavy method is called multiple times with the same inputs during the application's lifecycle,;;;;;
DynamicWaitTime;Energy;Suboptimal Algorithm, RPC/IPC;No;;;;;;✅;;;;;;;;;;This inspection identifies cases where the wait time between attempts to access a resource is constant. In those cases, the constant is changed to a dynamic value that grows with the number of attempts. It also considers the values used to put threads to sleep. <br>;;Implement exponential backoff instead of using constant wait times;*.java, *.kt;Warning;DynamicWaitTime1.txt;DynamicWaitTime2.txt;When polling a local resource or a very fast, reliable endpoint, a short, fixed retry interval might be more appropriate than an exponential backoff, which could introduce unnecessary delays.;A developer is creating a feature that polls a remote server for data availability. The implementation should try to get the data in several attempts before giving up and wait a while after each retry;;;;;
InfoWarningFCM;Energy;Obsolete Solution;Yes;;;;;;✅;;;;;;;;;; This inspection identifies cases where the method android.app.AlarmManager.setRepeating is used and adds a <i>TODO</i> to the source code to remind developers that it would be preferable to implement push notifications, rather than using a possible polling system. <br>;;Replace AlarmManager.setRepeating() (polling) with Firebase Cloud Messaging (FCM) for push notifications;*.java, *.kt;Warning;InfoWarningFCM1.txt;InfoWarningFCM2.txt;The application might be designed to work in environments where Google services (and thus FCM) are blocked or unavailable (e.g., certain regions or corporate networks). In this case, polling is the only viable alternative.;A developer is implementing a notification system that needs to periodically check for updates from a server. ;;;;;
PassiveProviderLocation;Energy;Resource Management;;;;;;;✅;;;;;;;;;; This inspection switches to a <i>LocationManager.PASSIVE_PROVIDER</i> when invoking the method <i>requestLocationUpdates</i> from the class <i>android.location.LocationManager;; Use LocationManager.PASSIVE_PROVIDER when location updates are needed but don’t require GPS;*.java, *.kt;Warning;PassiveProviderLocation1.txt;PassiveProviderLocation2.txt;The application may need a recent location fix but cannot rely on other apps to request one. While not wanting the power drain of GPS, it still needs to actively request a location (e.g., from the network provider), making the PASSIVE_PROVIDER insufficient for its needs.;A developer is building a fitness tracking app that needs location updates just to display the current weather on the user area.;;;;;
SSLSessionCaching;Energy;RPC/IPC;;;;;;;✅;;;;;;;;;;    This inspection applies the energy pattern https://tqrg.github.io/energy-patterns/#/patterns/Cache by attempting to increase the cache size of an SSL Session.    It identifies cases where the cache size is not already set to a specific value and removes any default ;;Increase SSL session cache size for better performance;*.java, *.kt;Warning;SSLSessionCaching1.txt;SSLSessionCaching2.txt;If an application makes very infrequent HTTPS requests to a wide variety of different domains, an SSL session cache would provide little to no performance benefit, as sessions would rarely be reused.;A developer is implementing secure network communication in their app. THe app requires establishing HTTPS connections to their server all the time. ;;;;;
URLCaching;Energy;RPC/IPC, Unnecessary Computation;;;;;;;✅;;;;;;;;;;This inspection identifies cases where no changes occur since the last update from an URL connection. It adds a <i>TODO</i> to the source code to remind developers that there is an opportunity to apply the energy pattern https://tqrg.github.io/energy-patterns/#/patterns/Cache;;Implement HTTP caching using HttpURLConnection;*.java, *.kt;Warning;URLCaching1.txt;URLCaching2.txt;The app might be communicating with an endpoint that provides real-time, non-cacheable data, such as a stock ticker or live sports scores. Caching this data would be functionally incorrect.;A developer is creating a news feed that fetches content from a remote server. Their implementation should use a HttpURLConnection for each refresh;;;;;
CheckLayoutSize;Energy;Resource Management, Unnecessary Computation;Yes;;;;;;✅;;;;;;;;;;  This inspection ensures that a layout is not drawn when its measurements are zero.   This is specific to the usage of the class android.view.SurfaceHolder.;;Ensure layouts are not drawn if their measurements are zero when using android.view.SurfaceHolder;*.java, *.kt;Warning;CheckLayoutSize1.txt;CheckLayoutSize2.txt;A developer might be intentionally relying on the underlying graphics system to clip or ignore drawing commands on a zero-sized surface, and an explicit check in the code is considered redundant.;A developer is implementing a custom SurfaceView for rendering graphics.;;;;;
CheckMetadata;Energy;Unnecessary Computation;;;;;;;✅;;;;;;;;;; This inspection identifies cases where a simple cache mechanism can be added in the method onReceive of subclasses of android.content.BroadcastReceiver. In those cases, the source code is refactored so that changes in the    values retrieved from the intent parameter are checked before processing the information received.<br>;; Implement a simple caching mechanism in onReceive() of BroadcastReceiver to avoid redundant processing.;*.java, *.kt;Warning;CheckMetadata1.txt;CheckMetadata2.txt;If the broadcast intent is guaranteed by its sender to always contain new, unique data, then checking it against a cached version of the previous intent's data would be redundant.;A developer is implementing a BroadcastReceiver that processes system events. In the onReceive() method, the app should process incoming intents and broadcast notifications ;;;;;
CheckNetwork;Energy;RPC/IPC;No;;;;;;✅;;;;;;;;;;  This inspection identifies cases where a network connection exists before processing a request. This is only activated when subclasses of android.app.IntentService are used. <br>;; Ensure network availability before processing requests in IntentService.;*.java, *.kt;Warning;CheckNetwork1.txt;CheckNetwork2.txt;The IntentService could be designed to work with a queueing system. It may intentionally attempt a network request and, upon failure, schedule the work to be retried later (e.g., using WorkManager), making an upfront network check unnecessary.;A developer is creating an IntentService that needs to download data from a server. The service should  make network requests to obtain the data;;;;;
DirtyRendering;Energy;Unnecessary Computation;Yes;;;;;;✅;;;;;;;;;;This inspection switches the rendering mode to <i>GLSurfaceView.RENDERMODE_WHEN_DIRTY;;Switch to lazy rendering using GLSurfaceView.RENDERMODE_WHEN_DIRTY.;*.java, *.kt;Warning;DirtyRendering1.txt;DirtyRendering2.txt;For a GLSurfaceView that is rendering a continuous animation, a video game, or a live camera feed, RENDERMODE_CONTINUOUSLY is the correct and necessary rendering mode. RENDERMODE_WHEN_DIRTY would result in a static image.;A developer is implementing a custom OpenGL ES view for a game that displays relatively static content with occasional updates. ;;;;;
ExcessiveLoopCallsDetector;Runtime;Unnecessary Computation, Suboptimal Algorithm;No;✅;;;;;;;;;;;;;;;Calling methods inside loops, either in the loop condition or in the body, is  usually a good optimization target;;Avoid method calls inside loops when possible by precomputing values outside the loop.;*.java, *.kt;Warning;ExcessiveLoopCallsDetector1.txt;ExcessiveLoopCallsDetector2.txt;he method call inside the loop is necessary when its return value is expected to change with each iteration. Hoisting the call outside the loop would be functionally incorrect.;A developer is implementing a task scheduler that needs to repeatedly execute a method at fixed intervals. They create a Handler and post a Runnable that calls updateStatus() inside a loop,;;;;;
NestedWeight;Runtime;Resource Management, Suboptimal Algorithm;Yes;;;✅;✅;;;;;;;;;;;✅;Layout weights require a widget to be measured twice. When a LinearLayout with non-zero weights is nested inside another LinearLayout with non-zero weights, then the number of measurements increase exponentially.;https://googlesamples.github.io/android-custom-lint-rules/checks/NestedWeights.md.html;Avoid nested LinearLayouts with weights by using ConstraintLayout or RelativeLayout instead.;*.xml;Warning;NestedWeight1.txt;NestedWeight2.txt;In a simple, non-scrolling UI, the performance impact of a nested weight is often negligible. A developer might choose this approach for its simplicity and speed of development compared to configuring a more complex ConstraintLayout.;"A developer is creating a complex layout for a messaging app interface. They use a LinearLayout with layout_weight to divide the screen between a ListView for messages (weight=""1"") and a bottom section for input. Within that bottom section, they create another LinearLayout with some more buttons.";;;;;
ConfigChanges;Energy;Resource Management;Yes;;✅;✅;;;;;;;;;;;;;In Android applications, it is considered a code smell if attribute android:configChanges is defined in Manifest file. This phenomenon leads to memory leaks;;Avoid handling android:configChanges in the AndroidManifest.xml and instead handle config changes properly in onSaveInstanceState().;*.xml;Warning;ConfigChanges1.txt;ConfigChanges2.txt;For an Activity that manages a real-time media stream (like a video player or a live camera feed), destroying and recreating the entire view hierarchy on rotation would cause an unacceptable disruption. In these specific cases, handling the configuration change manually is the recommended approach.;A developer is building an app that needs to maintain its UI state during screen rotations on its Activities.;;;;;
DroppedData;Runtime;Resource Management;No;;;✅;;;;;;;;;;;;;on Android applications, the data filled by user in any Activity or fragment may be lost if the focused screen is interrupted. Data should be saved and restored using overridable methods on SaveInstanceState and on RestoreInstanceState;; Preserve user data using onSaveInstanceState() and onRestoreInstanceState().;*.java, *.kt;Warning;DroppedData1.txt;DroppedData2.txt;A screen may be designed to display transient, real-time data (like a logcat viewer or a network monitor) that does not need to be saved and restored during configuration changes. In this case, implementing onSaveInstanceState is unnecessary.;A developer is creating a form for user registration within an activity. They need to implement input fields for name, email, and other details.;;;;;
CollectionOfBitmaps;Memory;Resource Management;Yes;;;✅;;;;;;;;;;;;;The collection of bitmaps is a resource intensive process and should be avoided;;Avoid loading multiple bitmaps in memory. Use bitmap pooling or LruCache.;*.java, *.kt;Warning;CollectionOfBitmaps1.txt;CollectionOfBitmaps2.txt;The collection might be an LruCache which is specifically designed to manage a memory-limited collection of bitmaps. The tool might not recognize it as a safe implementation.;A developer is implementing an image gallery that displays multiple high-resolution photos. They should store Bitmap objects in memory.;;;;;
CollectionOfViews;Memory;Resource Management;Yes;;;✅;;;;;;;;;;;;;The collection of views is a resource intensive process in Android applications and should be avoided;;Do not store views in collections;*.java, *.kt;Warning;CollectionOfViews1.txt;CollectionOfViews2.txt;A custom ViewGroup implementation often needs to store references to its child views to manage them. As long as these references do not outlive the ViewGroup itself, they do not constitute a memory leak.;A developer is creating a custom ViewGroup that needs to manage multiple child views and to track them across all the application, that has multive activities;;;;;
StaticBitmap;Memory;Code Smell;Yes;;;✅;✅;;;;;;;;;;;✅;Bitmaps are heavy objects and should be dealt with proper case otherwise it can lead to memory leaks.;;Do not store bitmaps in static fields. Use caching mechanisms like LruCache instead.;*.java, *.kt;Warning;StaticBitmap1.txt;StaticBitmap2.txt;While risky, if the bitmap is small, immutable, and loaded once to be used throughout the entire application lifecycle (e.g., a logo), it may not cause a leak if it's managed carefully and tied to the application context.;A developer is implementing an app that displays a company logo throughout different activities, manipulated via a Bitmap object;;;;;
StaticContext;Memory;Code Smell;Yes;;;✅;✅;;;;;;;;;;;✅;In Android applications, declaring field of type Context leads to memory leak as it is never collected by garbage collector of JVM;;In Android applications, declaring field of type Context leads to memory leak as it is never colllected by garbage collector of JVM;*.java, *.kt;Warning;StaticContext1.txt;StaticContext2.txt;Storing the Application Context (Context.getApplicationContext()) in a static field is a safe and common practice because the Application object lives for the entire duration of the app. The tool might incorrectly flag this without distinguishing it from an Activity context.;A developer wants easy access to application resources from any class;;;;;
StaticView;Memory;Code Smell;Yes;;;✅;✅;;;;;;;;;;;✅;Holding static reference of any view type object is a resource (memory) intensive process;;Avoid keeping static references to View objects to prevent memory leaks.;*.java, *.kt;Warning;StaticView1.txt;StaticView2.txt;This is almost always a leak. A highly contrived scenario could be a singleton view used for a system-level overlay window that is intended to persist across activities, but this is a very advanced and rare use case.;A developer is implementing a button that appears in multiple activities and wants to avoid recreating it;;;;;
StaticFieldLeak;Memory;Code Smell;No;;;;✅;;;;;;;;;;;✅;A static field will leak contexts. Non-static inner classes have an implicit reference to their outer class. If that outer class is for example a Fragment or Activity, then this reference means that the long-running handler/loader/task will hold a reference to the activity which prevents it from getting garbage collected. Similarly, direct field references to activities and fragments from these longer running instances can cause leaks. ViewModel classes should never point to Views or non-application Contexts.;https://googlesamples.github.io/android-custom-lint-rules/checks/StaticFieldLeak.md.html;Avoid static references to Activities, Fragments, and Views. If needed, use WeakReference.;*.java, *.kt;Warning;StaticFieldLeak1.txt;StaticFieldLeak2.txt;The static field might hold a reference that is explicitly cleared at the appropriate lifecycle event (e.g., set to null in Activity.onDestroy()). The static analysis tool may not be able to detect this manual cleanup.;A developer is implementing a background task to download and process data in an Android activity ;;;;;
UselessStringValueOf;Runtime;Data Manipulation, Unnecessary Computation;No;;;;;✅;;;;;;;;;;;No need to call String.valueOf to append to a string. Just use the valueOf() argument directly.;https://pmd.github.io/pmd/pmd_rules_java_performance.html#uselessstringvalueof;Just use the valueOf() argument directly to concatenate Strings;*.java, *.kt;Warning;UselessStringValueOf1.txt;UselessStringValueOf2.txt;Modern Java and Kotlin compilers are highly effective at optimizing string concatenations. A call to String.valueOf() before appending to a string is often optimized away, making the manual fix redundant and offering no performance benefit.;A developer is implementing a text formatting utility that builds custom strings by concatening string literals with numbers.;;;;;
AppendCharacterWithChar;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;✅;;;;;;;;;;;Avoid concatenating characters as strings in StringBuffer/StringBuilder.append methods.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#appendcharacterwithchar;Avoid concatenating characters using StringBuffer.append() or StringBuilder.append() with characters. use instead: StringBuffer sb = new StringBuffer() followed by sb.append('a');*.java, *.kt;Warning;AppendCharacterWithChar1.txt;AppendCharacterWithChar2.txt;This is a micro-optimization that modern compilers can often handle automatically. A developer might prefer using a string literal for consistency or readability, with a negligible impact on performance.;A developer is implementing a text formatting utility that builds custom strings character by character. They create a StringBuilder to construct the output and to append individual characters.;;;;;
AvoidArrayLoops;Runtime;Data Manipulation, Obsolete Solution;No;;;;;✅;;;;;;;✅;;;;Instead of manually copying data between two arrays, use the more efficient Arrays.copyOf or System.arraycopy method instead.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidarrayloops;Use System.arraycopy() or Arrays.copyOf() instead of looping through arrays.;*.java, *.kt;Warning;AvoidArrayLoops1.txt;AvoidArrayLoops2.txt;The loop in question may be doing more than just copying elements - it might be performing a transformation, filtering, or some other logic on each element as it is copied, which System.arraycopy() cannot do.;A developer is creating an image processing feature that needs to make a copy of pixel data from one array to another. ;;;;;
AvoidCalendarDateCreation;Runtime;Obsolete Solution, Unnecessary Computation;No;;;;;✅;;;;;;;;;;;java.util.Calendar is a heavyweight object and expensive to create. It should only be used, if calendar calculations are needed.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidcalendardatecreation;Use new Date(), Java 8+ java.time.LocalDateTime.now() or ZonedDateTime.now().;*.java, *.kt;Warning;AvoidCalendarDateCreation1.txt;AvoidCalendarDateCreation2.txt;The code may require calendar-specific calculations (e.g., adding days, getting the day of the week, handling time zones) for which java.util.Calendar was the standard API;A developer is building a scheduling app that frequently needs to check if events fall on specific days. ;;;;;
AvoidFileStream;Memory;Data Access, Obsolete Solution;No;;;;;✅;;;;;;;✅;;;;The FileInputStream and FileOutputStream classes contains a finalizer method which will cause garbage collection pauses. See JDK-8080225 for details. The FileReader and FileWriter constructors instantiate FileInputStream and FileOutputStream, again causing garbage collection issues while finalizer methods are called. Use Files.newInputStream(Paths.get(fileName)) instead of new FileInputStream(fileName). Use Files.newOutputStream(Paths.get(fileName)) instead of new FileOutputStream(fileName). Use Files.newBufferedReader(Paths.get(fileName)) instead of new FileReader(fileName). Use Files.newBufferedWriter(Paths.get(fileName)) instead of new FileWriter(fileName). Please note, that the java.nio API does not throw a FileNotFoundException anymore, instead it throws a NoSuchFileException. If your code dealt explicitly with a FileNotFoundException, then this needs to be adjusted. Both exceptions are subclasses of IOException, so catching that one covers both.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Use Files.newInputStream(Paths.get(fileName)) instead of new FileInputStream(fileName). Use Files.newOutputStream(Paths.get(fileName)) instead of new FileOutputStream(fileName). Use Files.newBufferedReader(Paths.get(fileName)) instead of new FileReader(fileName). Use Files.newBufferedWriter(Paths.get(fileName)) instead of new FileWriter(fileName). ;*.java, *.kt;Warning;AvoidFileStream1.txt;AvoidFileStream2.txt;The code must interface with an older, third-party library that specifically requires an instance of FileInputStream or FileOutputStream in its API, making the use of java.nio impossible.;A developer needs to implement a log file reader that processes application logs;;;;;
AvoidInstantiatingObjectsInLoops;Runtime;Unnecessary Computation;No;;;;;✅;;;;;;;✅;;;;New objects created within loops should be checked to see if they can created outside them and reused.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Avoid creating new objects inside loops if they can be reused outside the loop.;*.java, *.kt;Warning;AvoidInstantiatingObjectsInLoops1.txt;AvoidInstantiatingObjectsInLoops2.txt;It is impossible to create the object outside the loop if its constructor parameters depend on variables that change with each iteration.;A developer is processing a list of user transactions in a loop. For each transaction, they need to use a DateFormatter object to format the transaction date;;;;;
BigIntegerInstantiation;Memory;Data Manipulation, Unnecessary Computation;No;;;;;✅;;;;;;;;;;;Don’t create instances of already existing BigInteger (BigInteger.ZERO, BigInteger.ONE), for Java 1.5 onwards, BigInteger.TEN and BigDecimal (BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN) and for Java 9 onwards BigInteger.TWO.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html#avoidfilestream;Use existing BigInteger constants (BigInteger.ZERO, BigInteger.ONE, etc.) instead of instantiating new BigInteger objects.;*.java, *.kt;Warning;BigIntegerInstantiation1.txt;BigIntegerInstantiation2.txt;The code might be part of a library that needs to maintain compatibility with very old Java versions where constants like BigInteger.ZERO or BigInteger.ONE did not exist.;A developer is implementing a calculator feature that works with precise decimal values. They need to use BigInteger values;;;;;
ConsecutiveAppendsShouldReuse;Runtime;Data Manipulation, Code Smell;No;;;;;✅;;;;;;;;;;;Consecutive calls to StringBuffer/StringBuilder .append should be chained, reusing the target object. This can improve the performance by producing a smaller bytecode, reducing overhead and improving inlining.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Chain consecutive StringBuilder.append() or StringBuffer.append() calls to reduce bytecode size and improve performance.;*.java, *.kt;Warning;ConsecutiveAppendsShouldReuse1.txt;ConsecutiveAppendsShouldReuse2.txt;A developer may choose to write separate, unchained append calls for readability, especially if the calls are interspersed with comments or conditional logic. The performance gain from chaining is typically minimal.;A developer is building a string construction utility that generates complex formatted text from several class fields.;;;;;
ConsecutiveLiteralAppends;Runtime;Data Manipulation, Code Smell;No;;;;;✅;;;;;;;;;;;Consecutively calling StringBuffer/StringBuilder.append(…) with literals should be avoided.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid appending literals consecutively in StringBuilder. Instead, append once or use string concatenation if necessary.;*.java, *.kt;Warning;ConsecutiveLiteralAppends1.txt;ConsecutiveLiteralAppends2.txt;"Compilers almost always optimize consecutive literal appends (e.g., builder.append(""a"").append(""b"")) into a single operation (builder.append(""ab"")), making this warning moot.";A developer is creating an email template generator and needs to build a string using string literals.;;;;;
InefficientEmptyStringCheck;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;✅;;;;;;;;;;;String.trim().length() == 0 (or String.trim().isEmpty() for the same reason) is an inefficient way to check if a String is really blank;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html; Consider creating a static function that loops through a string, checking Character.isWhitespace() on each character and returning false if a non-whitespace character is found. Or using Apache’s StringUtils#isBlank (in commons-lang), Spring’s StringUtils#hasText (in the Spring framework) or Google’s CharMatcher#whitespace (in Guava) ;*.java, *.kt;Warning;InefficientEmptyStringCheck1.txt;InefficientEmptyStringCheck2.txt;The code's intent might be to specifically check if a string is empty after trimming whitespace, not just if it's blank. In that case, trim().isEmpty() is the correct logic, not an inefficient check for blankness.;A developer is validating user input in a form. They check if a text field is empty after trimming by using inputText.trim().length() == 0, which creates an unnecessary intermediate String object, instead of using the more efficient inputText.isEmpty() or checking the length before trimming.;;;;;
InefficientStringBuffering;Runtime;Data Manipulation;No;;;;;✅;;;;;;;✅;;;;Avoid concatenating non-literals in a StringBuffer constructor or append() since intermediate buffers will need to be be created and destroyed by the JVM.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid concatenating non-literals in a StringBuffer constructor or append() since intermediate buffers will need to be be created and destroyed by the JVM.;*.java, *.kt;Warning;InefficientStringBuffering1.txt;InefficientStringBuffering2.txt;"The compiler often optimizes simple string concatenations within a StringBuilder constructor or append call, making the flagged ""inefficiency"" a non-issue in the generated bytecode.";A developer is building a dynamic query generator for a database. They need to create a StringBuilder that contains a select statement to be performed over a table whose name is contained on a class field;;;;;
InsufficientStringBufferDeclaration;Runtime;Data Manipulation;No;;;;;✅;;;;;;;;;;;Failing to pre-size a StringBuffer or StringBuilder properly could cause it to re-size many times during runtime.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Pre-size the StringBuffer or StringBuilder when the expected size is known.;*.java, *.kt;Warning;InsufficientStringBufferDeclaration1.txt;InsufficientStringBufferDeclaration2.txt;If the final size of the string is unknown or highly variable, making a pre-sizing guess is impractical. A wrong guess could either lead to more reallocations (if too small) or wasted memory (if too large).;A developer is implementing a log formatting utility that concatenates various pieces of information. They need to create a StringBuffer and then append multiple string elements including timestamps, log levels, class names, and lengthy message content.;;;;;
OptimizableToArrayCall;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;✅;;;;;;;;;;;Calls to a collection’s toArray(E[]) method should specify a target array of zero size. This allows the JVM to optimize the memory allocation and copying as much as possible.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;When using toArray(), specify a zero-length array as an argument to allow for optimized memory allocation.;*.java, *.kt;Warning;OptimizableToArrayCall1.txt;OptimizableToArrayCall2.txt;"On modern JVMs (Java 8 and newer), providing a pre-sized array (list.toArray(new String[list.size()])) can be faster than passing an empty one (list.toArray(new String[0])). The ""optimized"" version could be a de-optimization on modern platforms.";A developer is implementing a feature to convert a collection of user preferences to an array for processing. It is required to use the toArray() method on an ArrayList;;;;;
RedundantFieldInitializer;Runtime;Code Smell;No;;;;;✅;;;;;;;;;;;Java will initialize fields with known default values so any explicit initialization of those same defaults is redundant and results in a larger class file (approximately three additional bytecode instructions per field).;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Remove redundant field initializations where default values are already provided by Java.;*.java, *.kt;Warning;RedundantFieldInitializer1.txt;RedundantFieldInitializer2.txt;Some coding standards require explicit initialization for all fields for the sake of clarity and consistency, even if the value is the type's default. This is a style choice, not a performance issue.;A developer is creating a data model class with dozens of fields of primitive  types to store user profile information;;;;;
StringInstantiation;Runtime;Data Manipulation, Unnecessary Computation;No;;;;;✅;;;;;;✅;;;;;Avoid instantiating String objects. Yhis is usually unnecessary since they are immutable and can be safely shared.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid instantiating String objects. This is usually unnecessary since they are immutable and canbe safely shared.;*.java, *.kt;Warning;StringInstantiation1.txt;StringInstantiation2.txt;A highly contrived scenario might be to intentionally force two string objects to have different identities in memory (== returns false) for a specific testing purpose.;A developer is implementing a text processing utility that needs to work with string constants.;;;;;
StringToString;Runtime;Data Manipulation, Unnecessary Computation;No;;;;;✅;;;;;;✅;;;;;Avoid calling toString() on objects already known to be string instances since this is unnecessary.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid instantiating new String objects when not necessary. Use string literals directly.;*.java, *.kt;Warning;StringToString1.txt;StringToString2.txt;In generic code (e.g., a method void process(T item)), a call to item.toString() is necessary for compilation. If the method is later called with a String, the toString() call is redundant at runtime but was required by the compiler.;A developer is building a string concatenation utility that combines various data types received as input. Namely, some of the inputs are Strings;;;;;
TooFewBranchesForSwitch;Runtime;Code Smell;No;;;;;✅;;;;;;;;;;;Switch statements are intended to be used to support complex branching behaviour. Using a switch for only a few cases is ill-advised, since switches are not as easy to understand as if-else statements. In these cases use the if-else statement to increase code readability.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;If a switch statement has too few cases, consider using an if-else statement for clarity and performance.;*.java, *.kt;Warning;TooFewBranchesForSwitch1.txt;TooFewBranchesForSwitch2.txt;A switch statement might be intentionally used for only one or two cases if the developer anticipates adding more cases in the future. It serves as a placeholder for future extension and can improve readability in that context.;A developer is implementing a feature to handle different user account types. They need to handle logic to deal with only two cases;;;;;
UseArrayListInsteadOfVector;Runtime;Obsolete Solution, Data Manipulation;No;;;;;✅;;;;;;;;;;;ArrayList is a much better Collection implementation than Vector if thread-safe operation is not required.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html; Use ArrayList instead of Vector for non-thread-safe collection needs as ArrayList is more efficient.;*.java, *.kt;Warning;UseArrayListInsteadOfVector1.txt;UseArrayListInsteadOfVector2.txt;The collection needs to be thread-safe. Vector is synchronized, whereas ArrayList is not. If the collection is accessed by multiple threads without external synchronization, using Vector is the correct and safe choice.;A developer is implementing a collection to store user notification objects in a single-threaded environment. ;;;;;
UseArraysAsList;Runtime;Obsolete Solution, Data Manipulation;No;;;;;✅;;;;;;;;;;;The java.util.Arrays class has a asList() method that should be used when you want to create a new List from an array of objects. It is faster than executing a loop to copy all the elements of the array one by one.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use Arrays.asList() to convert an array to a list, which is faster than manually iterating over the array.;*.java, *.kt;Warning;UseArraysAsList1.txt;UseArraysAsList2.txt;Arrays.asList() returns a fixed-size list. If the goal is to create a new, fully mutable list (where elements can be added or removed), a loop that copies elements into a new ArrayList is the correct approach.;A developer is converting an array of search results to a List for further processing.;;;;;
UseIndexOfChar;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;✅;;;;;;✅;;;;;Use String.indexOf(char) when checking for the index of a single character since it executes faster.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use String.indexOf(char) instead of manually checking the index of a character.;*.java, *.kt;Warning;UseIndexOfChar1.txt;UseIndexOfChar2.txt;"A developer might use indexOf(""c"") instead of indexOf('c') for stylistic consistency in code that also searches for multi-character strings. The performance difference is almost always negligible.";A developer is implementing a text parser that needs to find the position of specific characters in a string. ;;;;;
UseIOStreamsWithApacheCommonsFileItem;Runtime;Data Access, API Misuse;No;;;;;✅;;;;;;;;;;;Problem: Use of FileItem.get() and FileItem.getString() could exhaust memory since they load the entire file into memory.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Avoid using FileItem.get() and FileItem.getString() for large files. Use IO streams for better memory efficiency.;*.java, *.kt;Warning;UseIOStreamsWithApacheCommonsFileItem1.txt;UseIOStreamsWithApacheCommonsFileItem2.txt;The application may be designed to handle files that are guaranteed to be small (e.g., a user profile picture with a strict size limit, or a configuration file). In such cases, loading the entire file into memory with .get() or .getString() is safe and can be simpler to implement than handling I/O streams.;A developer is implementing a file upload feature using Apache Commons FileUpload. ;;;;;
UseStringBufferForStringAppends;Runtime;Data Manipulation;No;;;;;✅;;;;;;;;;;;The use of the ‘+=’ operator for appending strings causes the JVM to create and use an internal StringBuffer. If a non-trivial number of these concatenations are being used then the explicit use of a StringBuilder or threadsafe StringBuffer is recommended to avoid this.;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;Use StringBuffer or StringBuilder explicitly for string concatenations in loops to avoid creating too many intermediate objects.;*.java, *.kt;Warning;UseStringBufferForStringAppends1.txt;UseStringBufferForStringAppends2.txt;Modern Java compilers are capable of optimizing string concatenation with the += operator inside a loop into a single StringBuilder, making the manual optimization suggested by the warning redundant.;A developer is implementing a logging utility that needs to concatenate multiple pieces of information into a single log message. They need to do it on a loop;;;;;
UseStringBufferLength;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;✅;;;;;;;;;;;"Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("""") or StringBuffer.toString().length() == ";https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;"Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("""") or StringBuffer.toString().length() ==";*.java, *.kt;Warning;UseStringBufferLength1.txt;UseStringBufferLength2.txt;The performance difference between stringBuffer.length() and stringBuffer.toString().length() is negligible in almost all real-world scenarios. This is a micro-optimization that does not typically impact application performance.;A developer is creating a text input validation function that needs to check if a user's input contained in a StringBuffer is empty ;;;;;
AddEmptyString;Runtime;Data Manipulation, Unnecessary Computation;No;;;;;✅;;;;;;;✅;;;;The conversion of literals to strings by concatenating them with empty strings is inefficient. It is much better to use one of the type-specific toString() methods instead or String.valueOf().;https://docs.pmd-code.org/latest/pmd_rules_java_performance.html;"String s = """" + 123               / inefficient String  /\n t = Integer.toString(456)   // preferred approach";*.java, *.kt;Warning;AddEmptyString1.txt;AddEmptyString2.txt;"Using """" + myInt for string conversion is a common and concise idiom. While String.valueOf(myInt) is technically more performant, the difference is negligible and often optimized away by the compiler.";A developer is formatting numeric data for display. They need to convert each one of  several integers and doubles contained in class fields to a string;;;;;
UselessParent;Runtime;Resource Management;Yes;;;;✅;;;;;;;;;;;✅;A layout with children that has no siblings, is not a scrollview or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.;https://googlesamples.github.io/android-custom-lint-rules/checks/UselessParent.md.html;A layout that has no siblings, is not a ScrollView or root layout, and has no background can be removed. Its children can be directly placed into the parent layout for a more efficient and flatter hierarchy.;*.xml;Warning;UselessParent1.txt;UselessParent2.txt;A parent layout that appears useless may be used as a target for transitions or animations, or as a container for programmatically added views at runtime, giving it a valid purpose that static analysis cannot detect.;A developer is creating a custom list item layout for a RecyclerView;;;;;
UselessLeaf;Runtime;Resource Management;Yes;;;;✅;;;;;;;;;;;✅;A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.;https://googlesamples.github.io/android-custom-lint-rules/checks/UselessLeaf.md.html; A layout with no children or background can be removed to simplify the view hierarchy and improve performance.;*.xml;Warning;UselessLeaf1.txt;UselessLeaf2.txt;A layout that appears to be an empty leaf might serve as a dynamic placeholder that is populated with child views at runtime.;A developer is refactoring a complex layout and that used several FrameLayouts that was previously used as a container.;;;;;
AnimatorKeep;Runtime;Resource Management;Yes;;;;✅;;;;;;;;;;;✅;When you use property animators, properties can be accessed via reflection. Those methods should be annotated with @Keep to ensure that during release builds, the methods are not potentially treated as unused and removed, or treated as internal only and get renamed to something shorter. This check will also flag other potential reflection problems it encounters, such as a missing property, wrong argument types, etc.;https://googlesamples.github.io/android-custom-lint-rules/checks/AnimatorKeep.md.html;When using property animators, annotate the methods with @Keep to prevent them from being removed or renamed during release builds. This ensures that reflection-based access to properties works correctly.;*.java, *.kt;Warning;AnimatorKeep1.txt;AnimatorKeep2.txt;The @Keep annotation is redundant if the project's ProGuard/R8 configuration already has specific rules to prevent the animator's target methods from being removed or renamed.;A developer is implementing custom property animations for a view. They need to create methods to get and set custom properties;;;;;
ObsoleteSdkInt;Runtime;Obsolete Solution, Code Smell;Yes;;;;✅;;;;;;;;;;;✅;This check flags version checks that are not necessary, because the minSdkVersion (or surrounding known API level) is already at least as high as the version checked for. Similarly, it also looks for resources in -vNN folders, such as values-v14 where the version qualifier is less than or equal to the minSdkVersion, where the contents should be merged into the best folder.;https://googlesamples.github.io/android-custom-lint-rules/checks/ObsoleteSdkInt.md.html;Remove unnecessary SDK version checks when the minSdkVersion is already sufficient. If version-specific resources are available (e.g., values-v14), merge them into the appropriate folders based on the minSdkVersion.;*.java, *.kt;Warning;ObsoleteSdkInt1.txt;ObsoleteSdkInt2.txt;The code might reside in a library module that has a lower minSdkVersion than the main application module that consumes it. The version check is necessary for the library's standalone compatibility, even if it seems obsolete from the app's perspective.;A developer is updating an older app to target a newer Android version adn they need to avoid cases where the sdk version is lower than a certain deprecated version ;;;;;
DuplicateDivider;Runtime;Obsolete Solution, Code Smell;Yes;;;;✅;;;;;;;;;;;✅;Older versions of the RecyclerView library did not include a divider decorator, but one was provided as a sample in the support demos. This divider class has been widely copy/pasted into various projects. In recent versions of the support library, the divider decorator is now included, so you can replace custom copies with the “built-in” version, android.support.v7.widget.DividerItemDecoration.;https://googlesamples.github.io/android-custom-lint-rules/checks/DuplicateDivider.md.html;Replace custom divider decorators with the built-in DividerItemDecoration from the RecyclerView library, as it provides an optimized implementation for adding dividers.;*.java, *.kt;Warning;DuplicateDivider1.txt;DuplicateDivider2.txt;A custom divider implementation is necessary if it contains specific styling or logic (e.g., showing dividers only for certain item types) that the built-in DividerItemDecoration does not support.;A developer is implementing a list with dividers between items using RecyclerView.;;;;;
UseValueOf;Runtime;Data Manipulation, Unnecessary Computation;Yes;;;;✅;✅;;;;;;✅;;;;✅;You should not call the constructor for wrapper classes directly, such asnew Integer(42). Instead, call the valueOf factory method, such as Integer.valueOf(42). This will typically use less memory because common integers such as 0 and 1 will share a single instance.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseValueOf.md.html;You should not call the constructor for wrapper classes directly, such asnew Integer(42). Instead, call the valueOf factory method, such as Integer.valueOf(42). This will typically use less memory because common integers such as 0 and 1 will share a single instance.;*.java, *.kt;Warning;UseValueOf1.txt;UseValueOf2.txt;When dealing with integer values outside the standard cached range (-128 to 127), Integer.valueOf(i) and new Integer(i) both result in a new object allocation, making their performance identical.;A developer is parsing user input and converting it to Integer objects.;;;;;
UnpackedNativeCode;Runtime;Build Optimization;Yes;;;;✅;;;;;;;;;;;✅;"You can enable it by adding --enable UnpackedNativeCode This app loads native libraries using System.loadLibrary(). Consider adding android:extractNativeLibs=""false"" to the <application> tag in AndroidManifest.xml. Starting with Android 6.0, this will make installation faster, the app will take up less space on the device and updates will have smaller download sizes.";https://googlesamples.github.io/android-custom-lint-rules/checks/UnpackedNativeCode.md.html;"If you're loading native libraries via System.loadLibrary(), consider setting android:extractNativeLibs=""false"" in the AndroidManifest.xml to make installations faster, reduce app size, and make updates smaller.";*.xml;Warning;UnpackedNativeCode1.txt;UnpackedNativeCode2.txt;"The app may need to support older Android versions (pre-Marshmallow) where extractNativeLibs=""false"" is not supported. For compatibility across all API levels, a developer might choose to stick with the default extraction method.";A developer has to  integrate a native library into an Android app. the library should be importerd using System.loadLibrary() ;;;;;
UnusedResources;Runtime;Resource Management;Yes;;;;✅;;;;;;;;;;;✅;Unused resources make applications larger and slow down builds. The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead. You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true. ,;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedResources.md.html;emove unused resources from your project to reduce its size and speed up builds. Consider packaging resources used only in tests separately in a test source set. Example: Use lint.unused-resources.exclude-tests=true to exclude test resources from the check.;*.java, *.kt, *.xml;Warning;UnusedResources1.txt;UnusedResources2.txt;The resource might be accessed dynamically by name using Resources.getIdentifier(). Static analysis tools often cannot detect this type of reflective access and will incorrectly flag the resource as unused.;A developer is cleaning up their Android application before release. They have accumulated numerous layout files, drawables, and string resources during development and prototyping phases.  These unused resources remain in the project, increasing the APK size and slowing down build times.;;;;;
UnusedIds;Runtime;Resource Management, Code Smell;Yes;;;;✅;;;;;;;;;;;✅;This resource id definition appears not to be needed since it is not referenced from anywhere. Having id definitions, even if unused, is not necessarily a bad idea since they make working on layouts and menus easier, so there is not a strong reason to delete these. The unused resource check can ignore tests. If you want to include resources that are only referenced from tests, consider packaging them in a test source set instead. You can include test sources in the unused resource check by setting the system property lint.unused-resources.include-tests =true, and to exclude them (usually for performance reasons), use lint.unused-resources.exclude-tests =true.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedIds.md.html;Remove unused resource IDs, but keep in mind that they can help in the future during development. However, if you're sure they're not needed, you can delete them for a cleaner codebase.;*.java, *.kt, *.xml;Warning;UnusedIds1.txt;UnusedIds2.txt;;A developer is working on a complex UI layout where they defined multiple view IDs in anticipation of needing them for event handlers. As the development progressed, some of these views were removed or redesigned, leaving their ID definitions in the layout files without any references to them in the code. ;;;;;
InefficientWeight;Runtime;Resource Management, Suboptimal Algorithm;Yes;;;;✅;;;;;;;;;;;✅;When only a single widget in a LinearLayout defines a weight, it is more efficient to assign a width/height of 0dp to it since it will absorb all the remaining space anyway. With a declared width/height of 0dp it does not have to measure its own size first.;https://googlesamples.github.io/android-custom-lint-rules/checks/InefficientWeight.md.html;If only one widget in a LinearLayout has a weight, you should assign it a width or height of 0dp to make layout calculations more efficient.;*.xml;Warning;InefficientWeight1.txt;InefficientWeight2.txt;The layout might be altered at runtime where another view is added. The weight on the single initial view is there to ensure it correctly resizes when its sibling appears later.;A developer is creating a layout where a button needs to take up all remaining space in a horizontal LinearLayout after a fixed-width TextView.;;;;;
DisableBaselineAlignment;Runtime;Resource Management, Suboptimal Algorithm;Yes;;;;✅;;;;;;;;;;;✅;When a LinearLayout is used to distribute the space proportionally between nested layouts, the baseline alignment property should be turned off to make the layout computation faster.;https://googlesamples.github.io/android-custom-lint-rules/checks/DisableBaselineAlignment.md.html;When using LinearLayout to distribute space, turn off the baseline alignment property to speed up layout computation.;*.xml;Warning;DisableBaselineAlignment1.txt;DisableBaselineAlignment2.txt;The LinearLayout might contain TextViews or other text-based views where aligning the text's baseline is an intentional part of the UI design, even if it has a small performance cost.;A developer is implementing a complex screen layout using nested LinearLayouts with weights to distribute space proportionally. ;;;;;
MergeRootFrame;Runtime;Resource Management;Yes;;;;✅;;;;;;;;;;;✅;If a <framelayout> is the root of a layout and does not provide background or padding etc, it can often be replaced with a <merge> tag which is slightly more efficient. Note that this depends on context, so make sure you understand how the <merge> tag works before proceeding.;https://googlesamples.github.io/android-custom-lint-rules/checks/MergeRootFrame.md.html;If a FrameLayout is the root layout and does not provide background, padding, etc., it can be replaced with a merge tag to improve efficiency.;*.xml;Warning;MergeRootFrame1.txt;MergeRootFrame2.txt;A <FrameLayout> might be required as the root because the code expects to apply specific FrameLayout.LayoutParams to a child view that is added programmatically. A <merge> tag would not support this.;A developer is creating a reusable layout component. This layout doesn't provide any background, padding, or other styling. ;;;;;
DevModeObsolete;Runtime;Build Optimization, Obsolete Solution;Yes;;;;✅;;;;;;;;;;;✅;In the past, our documentation recommended creating a dev product flavor with has a minSdkVersion of 21, in order to enable multidexing to speed up builds significantly during development. That workaround is no longer necessary, and it has some serious downsides, such as breaking API access checking (since the true minSdkVersion is no longer known). In recent versions of the IDE and the Gradle plugin, the IDE automatically passes the API level of the connected device used for deployment, and if that device is at least API 21, then multidexing is automatically turned on, meaning that you get the same speed benefits as the dev product flavor but without the downsides.;https://googlesamples.github.io/android-custom-lint-rules/checks/DevModeObsolete.md.html;The workaround of creating a dev product flavor with minSdkVersion 21 to enable multidexing is no longer necessary. Multidexing is now handled automatically if the connected device runs API 21 or higher. Simply ensure you're using the appropriate Gradle configuration without the dev flavor workaround.;*.gradle;Warning;DevModeObsolete1.txt;DevModeObsolete2.txt;The developer may be working on an old or highly customized build system where the IDE's automatic API level detection does not work correctly, making the dev product flavor a reliable manual workaround.;"A developer is trying to speed up development builds by creating a separate ""dev"" product flavor";;;;;
LifecycleAnnotationProcessorWithJava8;Runtime;Build Optimization, Obsolete Solution;Yes;;;;✅;;;;;;;;;;;✅;"For faster incremental build, switch to the Lifecycle Java 8 API with these steps: First replace annotationProcessor ""androidx.lifecycle:lifecycle-compiler:*version*"" kapt ""androidx.lifecycle:lifecycle-compiler:*version*"" with implementation ""androidx.lifecycle:lifecycle-common-java8:*version*"" Then remove any OnLifecycleEvent annotations from Observer classes and make them implement the DefaultLifecycleObserver interface.";https://googlesamples.github.io/android-custom-lint-rules/checks/LifecycleAnnotationProcessorWithJava8.md.html;"For faster incremental builds, switch to the Lifecycle Java 8 API by replacing annotationProcessor ""androidx.lifecycle:lifecycle-compiler"" with implementation ""androidx.lifecycle:lifecycle-common-java8"". Also, remove any OnLifecycleEvent annotations and use DefaultLifecycleObserver.";*.java, *.kt;Warning;LifecycleAnnotationProcessorWithJava81.txt;LifecycleAnnotationProcessorWithJava82.txt;The project may be unable to use Java 8 language features due to other constraints (e.g., compatibility with a critical library), making the switch to the lifecycle-common-java8 dependency impossible.;A developer is implementing lifecycle-aware components in their application using Java 8.;;;;;
AnnotationProcessorOnCompilePath;Runtime;Build Optimization;Yes;;;;✅;;;;;;;;;;;✅;This dependency is identified as an annotation processor. Consider adding it to the processor path using annotationProcessor instead of including it to the compile path.;https://googlesamples.github.io/android-custom-lint-rules/checks/AnnotationProcessorOnCompilePath.md.html; If an annotation processor is included in the compile classpath, move it to the annotationProcessor path instead to optimize the build process.;*.gradle;Warning;AnnotationProcessorOnCompilePath1.txt;AnnotationProcessorOnCompilePath2.txt;The dependency might be a hybrid library that is not purely an annotation processor but also provides classes that are needed on the compile classpath. In this case, using implementation is necessary.;A developer is adding an annotation processor library (like Dagger or Butterknife) to their project's dependencies;;;;;
LogConditional;Runtime;Code Smell;Yes;;;;✅;;;;;;;;;;;✅;The BuildConfig class provides a constant, DEBUG, which indicates whether the code is being built in release mode or in debug mode. In release mode, you typically want to strip out all the logging calls. Since the compiler will automatically remove all code which is inside a if (false) check, surrounding your logging calls with a check for BuildConfig.DEBUG is a good idea. If you really intend for the logging to be present in release mode, you can suppress this warning with a @SuppressLint annotation for the intentional logging calls.;https://googlesamples.github.io/android-custom-lint-rules/checks/LogConditional.md.html;Wrap log statements in a check for BuildConfig.DEBUG to ensure logging is only active in debug builds and automatically removed from release builds.;*.java, *.kt;Warning;LogConditional1.txt;LogConditional2.txt;The log statement may be for a critical event (e.g., a security audit or a non-fatal error for Crashlytics) that must be recorded even in release builds.;A developer is implementing logging throughout their application for debugging purposes only;;;;;
WearableBindListener;Runtime;Obsolete Solution;Yes;;;;✅;;;;;;;;;;;✅;BIND_LISTENER receives all Android Wear events whether the application needs them or not. This can be inefficient and cause applications to wake up unnecessarily. With Google Play Services 8.2.0 or later it is recommended to use a more efficient combination of manifest listeners and api-based live listeners filtered by action, path and/or path prefix.;https://googlesamples.github.io/android-custom-lint-rules/checks/WearableBindListener.md.html;For Android Wear apps, avoid using the BIND_LISTENER unless necessary, as it can cause inefficiency by waking the app unnecessarily. Use manifest listeners and API-based live listeners instead.;*.xml;Fatal;WearableBindListener1.txt;WearableBindListener2.txt;;A developer is creating a Wear OS application to receive Android Wear events;;;;;
UsableSpace;Memory;Data Access, Obsolete Solution;Yes;;;;✅;;;;;;;;;;;✅;When you need to allocate disk space for large files, consider using the new allocateBytes(FileDescriptor, long) API, which will automatically clear cached files belonging to other apps (as needed) to meet your request. When deciding if the device has enough disk space to hold your new data, call getAllocatableBytes(UUID) instead of using getUsableSpace(), since the former will consider any cached data that the system is willing to clear on your behalf.Note that these methods require API level 26. If your app is running on older devices, you will probably need to use both APIs, conditionally switching on Build.VERSION.SDK_INT. Lint only looks in the same compilation unit to see if you are already using both APIs, so if it warns even though you are already using the new API, consider moving the calls to the same file or suppressing the warning.;https://googlesamples.github.io/android-custom-lint-rules/checks/UsableSpace.md.html;When allocating disk space for large files, use allocateBytes(FileDescriptor, long) (API level 26+) to clear other app’s cached files if needed. Use getAllocatableBytes(UUID) for checking space availability instead of getUsableSpace().;*.java, *.kt;Warning;UsableSpace1.txt;UsableSpace2.txt;For an application targeting an API level below 26, using getUsableSpace() is the only option available. The warning is a false positive if the developer has not yet implemented the conditional logic to use the newer APIs on supported devices.;A developer is implementing a file download manager that needs to check if there's enough space before downloading large media files.;;;;;
VectorPath;Runtime;Resource Management;Yes;;;;✅;;;;;;;;;;;✅;Using long vector paths is bad for performance. There are several ways to make the pathData shorter:Using less precision, Removing some minor details, Using the Android Studio vector conversion tool, Rasterizing the image (converting to PNG);https://googlesamples.github.io/android-custom-lint-rules/checks/VectorPath.md.html;void using long vector paths as they negatively affect performance. You can reduce path data by: Reducing precision, Removing minor details, Using Android Studio's vector conversion tool, Rasterizing the image to PNG (if vector paths are not necessary).;*.java, *.kt, *.xml;Warning;VectorPath1.txt;VectorPath2.txt;The complex vector could be a company logo or an asset from a designer where simplification would violate brand guidelines or be too time-consuming for a negligible performance gain on modern devices.;A developer is converting a complex logo from SVG to Android vector drawable format.;;;;;
UnusedNamespace;Runtime;Resource Management, Code Smell;Yes;;;;✅;;;;;;;;;;;✅;Unused namespace declarations take up space and require processing that is not necessary.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnusedNamespace.md.html; Remove unused namespace declarations from your XML files as they take up unnecessary space and require additional processing.;*.java, *.kt, *.xml;Warning;UnusedNamespace1.txt;UnusedNamespace2.txt;;A developer is creating an XML layout file for a new screen in their Android application. When setting up the layout, they include multiple namespace declarations at the root level (such as xmlns:app, xmlns:tools, and xmlns:custom) to access various attributes.;;;;;
RedundantNamespace;Runtime;Resource Management, Code Smell;Yes;;;;✅;;;;;;;;;;;✅;In Android XML documents, only specify the namespace on the root/document element. Namespace declarations elsewhere in the document are typically accidental leftovers from copy/pasting XML from other files or documentation.;https://googlesamples.github.io/android-custom-lint-rules/checks/RedundantNamespace.md.html; Only specify the namespace on the root element of your XML document. Other redundant namespace declarations are typically accidental leftovers from copying/pasting XML code.;*.xml;Warning;RedundantNamespace1.txt;RedundantNamespace2.txt;;"A developer is creating a custom layout by copying elements from various XML files. They inadvertently include namespace declarations (xmlns:android=""http://schemas.android.com/apk/res/android"") on multiple elements within the same document, not just on the root element.";;;;;
ViewTag;Memory;Obsolete Solution;Yes;;;;✅;;;;;;;;;;;✅;Prior to Android 4.0, the implementation of View.setTag(int, Object) would store the objects in a static map, where the values were strongly referenced. This means that if the object contains any references pointing back to the context, the context (which points to pretty much everything else) will leak. If you pass a view, the view provides a reference to the context that created it. Similarly, view holders typically contain a view, and cursors are sometimes also associated with views.;https://googlesamples.github.io/android-custom-lint-rules/checks/ViewTag.md.html;Avoid using View.setTag(int, Object) before Android 4.0 as it could cause memory leaks due to static map references. This can result in the context being leaked if the tag holds a reference back to the context.;*.java, *.kt;Warning;ViewTag1.txt;ViewTag2.txt;The warning is only relevant for apps running on Android versions prior to 4.0 (API 16). On any reasonably modern device, this is a non-issue. Furthermore, if the object being set as a tag does not hold a reference to a Context (e.g., it's a simple String or a number), it cannot cause a context leak.;A developer is implementing a ListView with complex items and needs to store references to views for the ViewHolder pattern.;;;;;
TooManyViews;Runtime;Resource Management, Suboptimal Algorithm;Yes;;;;✅;;;;;;;;;;;✅;Using too many views in a single layout is bad for performance. Consider using compound drawables or other tricks for reducing the number of views in this layout.The maximum view count defaults to 80 but can be configured with the environment variable ANDROID_LINT_MAX_VIEW_COUNT.;https://googlesamples.github.io/android-custom-lint-rules/checks/TooManyViews.md.html;Limit the number of views in a single layout. Too many views degrade performance. Consider combining elements using compound drawables or optimizing your layout structure. Example: If you have too many views, try using CompoundDrawables or a flatter layout.;*.xml;Warning;TooManyViews1.txt;TooManyViews2.txt;"The layout might be for a rarely used, non-scrolling screen, like a detailed ""About"" or diagnostic page. Here, performance is not a concern, and using many views might be the simplest way to design it.";A developer is designing a complex settings screen with numerous options. They need create to create a layout with almost 100 individual view elements;;;;;
TooDeepLayout;Runtime;Resource Management, Suboptimal Algorithm;Yes;;;;✅;;;;;;;;;;;✅;Layouts with too much nesting is bad for performance. Consider using a flatter layout (such as RelativeLayout or GridLayout).The default maximum depth is 10 but can be configured with the environment variable ANDROID_LINT_MAX_DEPTH.;https://googlesamples.github.io/android-custom-lint-rules/checks/TooDeepLayout.md.html;Excessively nested layouts impact performance. Consider flattening the layout structure or using more efficient layouts like RelativeLayout or GridLayout.Example: If your layout has more than 10 nested views, consider restructuring it for better performance.;*.xml;Warning;TooDeepLayout1.txt;TooDeepLayout2.txt;A deep layout can be the result of composing several reusable custom components. In this case, the architectural benefit of modularity and reusability might be prioritized over having a flat view hierarchy.;A developer is creating a UI with multiple nested layouts to achieve a specific visual arrangement. ;;;;;
UseCompoundDrawables;Runtime;Resource Management, Suboptimal Algorithm;Yes;;;;✅;;;;;;;;;;;✅;A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable (a single TextView, using the drawableTop, drawableLeft, drawableRight and/or drawableBottom attributes to draw one or more images adjacent to the text).;https://googlesamples.github.io/android-custom-lint-rules/checks/UseCompoundDrawables.md.html;Combine ImageView and TextView using drawableLeft, drawableTop, drawableRight, or drawableBottom attributes to improve performance instead of adding multiple views.;*.xml;Warning;UseCompoundDrawables1.txt;UseCompoundDrawables2.txt;Using a separate ImageView is necessary if the image needs a contentDescription for accessibility or requires complex scaling/positioning that a compound drawable does not support.;A developer is creating list items that display an icon next to text. ;;;;;
UseOfBundledGooglePlayServices;Memory;Build Optimization;Yes;;;;✅;;;;;;;;;;;✅;Google Play services SDK's can be selectively included, which enables a smaller APK size. Consider declaring dependencies on individual Google Play services SDK's. If you are using Firebase API's(https://firebase.google.com/docs/android/setup), Android Studio's Tools → Firebase assistant window can automatically add just the dependencies needed for each feature.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseOfBundledGooglePlayServices.md.html;Declare dependencies of individual Google Play services SDK's;*.gradle;Warning;UseOfBundledGooglePlayServices1.txt;UseOfBundledGooglePlayServices2.txt;A project might be very old or complex, and the effort required to refactor all Google Play Services dependencies to be modular is significant. The developer may have made a conscious decision to accept the larger APK size to avoid the risk of a complex refactoring.;A developer has to add Google Play Services to their app ;;;;;
StringFormatTrivial;Runtime;Data Manipulation, Unnecessary Computation;Yes;;;;✅;;;;;;;;;;;✅;Every call to String.format creates a new Formatter instance, which will decrease the performance of your app. String.format should only be used when necessary—if the formatted string contains only trivial conversions (e.g. b, s, c) and there are no translation concerns, it will be more efficient to replace them and concatenate with +.;https://googlesamples.github.io/android-custom-lint-rules/checks/StringFormatTrivial.md.html;void using String.format for trivial string formatting as it creates a new Formatter instance, which reduces performance. Instead, concatenate strings where no translation is needed.;*.java, *.kt;Warning;StringFormatTrivial1.txt;StringFormatTrivial2.txt;If a string is marked for translation (i.e., it is in strings.xml), String.format is the correct way to handle parameter substitution. Using simple + concatenation would break the string for other languages where the word order is different.;A developer is building strings for logging or display.;;;;;
AssertionSideEffect;Runtime;Unnecessary Computation, Code Smell;Yes;;;;✅;;;;;;;;;;;✅;There's a lint quickfix to perform this conversion in the Eclipse plugin.;https://googlesamples.github.io/android-custom-lint-rules/checks/AssertionSideEffect.md.html;Make sure assertions do not have side effects in your code as they could cause unnecessary computation in release builds. This could lead to wasted work.;*.java, *.kt;Warning;AssertionSideEffect1.txt;AssertionSideEffect2.txt;The side effect within an assertion might be intentional for debugging purposes (e.g., incrementing a debug counter) and is correctly removed from release builds, so it has no impact on production code.;A developer is implementing input validation for a heavy financial calculation. it requires performing assertions to verify that input values are within expected range.;;;;;
DuplicateStrings;Runtime;Resource Management, Code Smell;Yes;;;;✅;;;;;;;;;;;✅;Duplicate strings can make applications larger unnecessarily. This lint check looks for duplicate strings, including differences for strings where the only difference is in capitalization. Title casing and all uppercase can all be adjusted in the layout or in code.;https://googlesamples.github.io/android-custom-lint-rules/checks/DuplicateStrings.md.html;duplicate strings (including those differing only by case). These increase the size of the application unnecessarily.;*.xml;Warning;DuplicateStrings1.txt;DuplicateStrings2.txt;"Although the strings are identical in the source language, they might represent different concepts that require different translations in another language (e.g., ""OK"" as a button label vs. ""OK"" as a status).";A developer is localizing their application and has to define multiple similar strings in the strings.xml resource file;;;;;
ExpensiveAssertion;Runtime;Unnecessary Computation, Code Smell;Yes;;;;✅;;;;;;;;;;;✅;In Kotlin, assertions are not handled the same way as from the Java programming language. In particular, they're just implemented as a library call, and inside the library call the error is only thrown if assertions are enabled.This means that the arguments to the assert call will always be evaluated. If you're doing any computation in the expression being asserted, that computation will unconditionally be performed whether or not assertions are turned on. This typically turns into wasted work in release builds. This check looks for cases where the assertion condition is nontrivial, e.g. it is performing method calls or doing more work than simple comparisons on local variables or fields.;https://googlesamples.github.io/android-custom-lint-rules/checks/ExpensiveAssertion.md.html;n Kotlin, assertions are implemented as library calls, meaning computations in the assert statement are always evaluated regardless of whether assertions are enabled. Avoid performing expensive computations within assertions.;*.java, *.kt;Warning;ExpensiveAssertion1.txt;ExpensiveAssertion2.txt;The assertion may be located in a test-only source set (src/test or src/androidTest) that is not compiled into the release application. In this context, its performance cost is irrelevant.;A developer is using Kotlin to implement data validation in a processing pipeline. He need to write an assertion that calls a complex validation method;;;;;
LaunchActivityFromNotification;Runtime;Code Smell;Yes;;;;✅;;;;;;;;;;;✅;Notifications should only launch activities — that's what users expect (and has been the guidance in both the Android SDK and Material Design documentation for a while).;https://googlesamples.github.io/android-custom-lint-rules/checks/LaunchActivityFromNotification.md.html;Notifications should launch activities, as that is what users expect. Avoid launching services or other components from notifications.;*.java, *.kt;Warning;LaunchActivityFromNotification1.txt;LaunchActivityFromNotification2.txt;"A notification may have action buttons that are intended to perform a background task without bringing the app to the foreground (e.g., ""Mark as Read"" or ""Delete""). These actions correctly launch a Service or BroadcastReceiver, not an Activity.";A developer is implementing a notification system for their messaging app. When a new message arrives a certain operation needs to start an operation that might need to trigger a background task;;;;;
NotificationTrampoline;Runtime;Obsolete Solution;Yes;;;;✅;;;;;;;;;;;✅;A Service or a BroadcastReceiver should not be used as an intermediate, because this can lead to significant performance problems, and as a result, this will not be allowed in Android 12.;https://googlesamples.github.io/android-custom-lint-rules/checks/NotificationTrampoline.md.html;Avoid using a Service or BroadcastReceiver as an intermediary for launching activities from notifications, as this can cause performance issues. This behavior will be disallowed starting from Android 12.;*.java, *.kt;Error;NotificationTrampoline1.txt;NotificationTrampoline2.txt;This pattern was common and permissible before Android 12. The code may be part of an app that has not yet been updated to target the newer SDK, making the warning a forward-compatibility issue rather than a current bug.;A developer is building a notification feature that needs to perform some background work before showing UI.;;;;;
AutoboxingStateCreation;Runtime;Data Manipulation;No;;;;✅;;;;;;;;;;;✅;Calling mutableStateOf<t>() when T is either backed by a primitive type on the JVM or is a value class results in a state implementation that requires all state values to be boxed. This usually causes an additional allocation for each state write, and adds some additional work to auto-unbox values when reading the value of the state. Instead, prefer to use a specialized primitive state implementation for Int, Long, Float, and Double when the state does not need to track null values and does not override the default SnapshotMutationPolicy. See mutableIntStateOf(), mutableLongStateOf(), mutableFloatStateOf(), and mutableDoubleStateOf() for more information.;https://googlesamples.github.io/android-custom-lint-rules/checks/AutoboxingStateCreation.md.html;Use mutableIntStateOf(), mutableLongStateOf(), etc. instead of mutableStateOf() for primitives.;*.java, *.kt;Warning;AutoboxingStateCreation1.txt;AutoboxingStateCreation2.txt;The primitive specializations like mutableIntStateOf do not support null values. If the state needs to be nullable (e.g., MutableState<Int?>), the generic mutableStateOf must be used.;A developer is implementing a Jetpack Compose UI that needs to track an integer counter. ;;;;;
AutoboxingStateValueProperty;Runtime;Data Manipulation, Unnecessary Computation;No;;;;✅;;;;;;;;;;;✅;Avoid using the generic value property when using a specialized State type. Reading or writing to the state's generic value property will result in an unnecessary autoboxing operation. Prefer the specialized value property (e.g. intValue for MutableIntState), or use property delegation to avoid unnecessary allocations.;https://googlesamples.github.io/android-custom-lint-rules/checks/AutoboxingStateValueProperty.md.html;Use .intValue, .longValue, etc., instead of .value when using specialized state types.;*.java, *.kt;Warning;AutoboxingStateValueProperty1.txt;AutoboxingStateValueProperty2.txt;The code may be part of a generic composable function that operates on MutableState<T>. To compile, this generic code must use the .value property. The warning becomes a false positive when T happens to be a primitive type like Int.;A developer is working with a specialized MutableIntState in Jetpack Compose. It is required to access the state value;;;;;
FrequentlyChangedStateReadInComposition;Runtime;Unnecessary Computation;Yes;;;;✅;;;;;;;;;;;✅;This property is observable and is updated after every scroll or remeasure. If you use it in the composable function directly, it will be recomposed on every change, causing potential performance issues including infinity recomposition loops. Prefer wrapping it with derivedStateOf to use calculation based on this property in composition or collect changes inside LaunchedEffect instead.;https://googlesamples.github.io/android-custom-lint-rules/checks/FrequentlyChangedStateReadInComposition.md.html;Wrap frequently updated state in derivedStateOf to reduce recompositions.;*.java, *.kt;Warning;FrequentlyChangedStateReadInComposition1.txt;FrequentlyChangedStateReadInComposition2.txt;The recomposition might be intentional and desired. For example, a debugging tool that displays real-time scroll coordinates needs to recompose on every scroll change.;"A developer is implementing a scrollable list in Jetpack Compose. It it required to implement composable function to show a ""scroll to top"" button";;;;;
KaptUsageInsteadOfKsp;Runtime;Build Optimization, Obsolete Solution;Yes;;;;✅;;;;;;;;;;;✅;KSP is a more efficient replacement for kapt. For libraries that support both, KSP should be used to improve build times.;https://googlesamples.github.io/android-custom-lint-rules/checks/KaptUsageInsteadOfKsp.md.html;Switch to KSP for annotation processing if supported.;*.gradle;Warning;KaptUsageInsteadOfKsp1.txt;KaptUsageInsteadOfKsp2.txt;The project may depend on a library that provides an annotation processor but does not yet offer support for KSP. In this case, the developer is forced to continue using KAPT for that processor.;A developer is setting up dependency injection with Dagger Hilt in their project. They need to configure the build.gradle file to use annotation processing;;;;;
NotifyDataSetChanged;Runtime;Suboptimal Algorithm, Obsolete Solution;Yes;;;;✅;;;;;;;;;;;✅;The RecyclerView adapter's onNotifyDataSetChanged method does not specify what about the data set has changed, forcing any observers to assume that all existing items and structure may no longer be valid. LayoutManagers will be forced to fully rebind and relayout all visible views.;https://googlesamples.github.io/android-custom-lint-rules/checks/NotifyDataSetChanged.md.html;Use specific update methods (notifyItemInserted(), notifyItemRemoved()) or DiffUtil;*.java, *.kt;Warning;NotifyDataSetChanged1.txt;NotifyDataSetChanged2.txt;When the underlying data source has changed so fundamentally that calculating fine-grained update events is impossible or more expensive than a full redraw (e.g., after a full data refresh from a server), notifyDataSetChanged() is the correct and intended fallback mechanism.;A developer is implementing a dynamic list with RecyclerView that updates when new data arrives. ;;;;;
UnnecessaryArrayInit;Runtime;Data Manipulation, Unnecessary Computation;No;;;;✅;;;;;;;;;;;✅;When constructing an array in Kotlin, you don't need to pass a lambda to set the initial value if it's identical to the default or if you're going to overwrite all the values without reading them anyway.;https://googlesamples.github.io/android-custom-lint-rules/checks/UnnecessaryArrayInit.md.html;don't  explicitly inititialize an array with zeroed values if not needed. Example: val startPoints = remember { IntArray(4) { 0 } };*.java, *.kt;Warning;UnnecessaryArrayInit1.txt;UnnecessaryArrayInit2.txt;The array may only be partially overwritten after initialization. In this case, the explicit initialization is necessary to ensure that all unwritten elements have a known default value.;A developer is creating an array to store temporary calculation results in Kotlin. ;;;;;
SyntheticAccessor;Runtime;Suboptimal Algorithm;No;;;;✅;;;;;;;;;;;✅;A private inner class which is accessed from the outer class will force the compiler to insert a synthetic accessor. this means that you are causing extra overhead. This is not important in small projects, but is important for large apps running up against the 64K method handle limit, and especially for libraries where you want to make sure your library is as small as possible for the cases where your library is used in an app running up against the 64K limit.;https://googlesamples.github.io/android-custom-lint-rules/checks/SyntheticAccessor.md.html;Change the modifier of the class, method or field to protected or public;*.java, *.kt;Warning;SyntheticAccessor1.txt;SyntheticAccessor2.txt;A developer might choose to keep a member private and accept the minor performance overhead of a synthetic accessor as a trade-off for maintaining stricter encapsulation, rather than widening its visibility to package-private or protected.;A developer is creating a inner class that needs to access fields or methods from the outer class;;;;;
UseOfNonLambdaOffsetOverload;Runtime;Unnecessary Computation;No;;;;✅;;;;;;;;;;;✅;Modifier.offset() is recommended to be used with static arguments only to avoid unnecessary recompositions. Modifier.offset{ } is preferred in the cases where the arguments are backed by a State.;https://googlesamples.github.io/android-custom-lint-rules/checks/UseOfNonLambdaOffsetOverload.md.html;Use Modifier.offset {} instead of Modifier.offset(x, y) for state-backed offsets.;*.java, *.kt;Warning;UseOfNonLambdaOffsetOverload1.txt;UseOfNonLambdaOffsetOverload2.txt;The offset value may be calculated from multiple, complex state objects. A developer might perform this calculation outside the offset modifier for better code clarity and pass the final result to the non-lambda overload, accepting the potential for extra recompositions as a trade-off for readability.;A developer is implementing an animated UI element in Jetpack Compose that changes position based on user interaction.;;;;;
InefficientKeySetIterator;Runtime;Data Manipulation, Suboptimal Algorithm;NO;;;;;;;;;;;✅;;✅;;✅?;Occurs when there are inefficient uses of iterators that iterate on keys then lookup their values, instead of iterating on key-value pairs directly;https://fbinfer.com/docs/all-issue-types#inefficient_keyset_iterator;It is more efficient to iterate over the loop with entrySet which returns key-vaue pairs and gets rid of the hashMap lookup.;*.java, *.kt;Warning;InefficientKeySetIterator1.txt;InefficientKeySetIterator2.txt;In a loop where the value associated with the key is only needed conditionally, iterating keySet and calling get() only when necessary could, in rare cases, be more performant than creating an Entry object for every single item via entrySet.;A developer needs to iterate a Map instance and access values corresponding to  keys;;;;;
InvariantCall;Runtime;Unnecessary Computation;No;;;;;;;;;;;;;✅;;✅?;Missed opportunities to hoist function calls that are invariant to outside of loop bodies. This happens when the function has no side side effects (pure), has invariant arguments and result (i.e. have the same value in all loop iterations) and it is guaranteed to execute, i.e. it dominates all loop sources;https://fbinfer.com/docs/all-issue-types#invariant_call;Move the function to outside of the loop body;*.java, *.kt;Warning;InvariantCall1.txt;InvariantCall2.txt;"The static analysis tool may incorrectly identify a method as ""invariant"" or ""pure."" The method might have hidden side effects or depend on a global state that can change during the loop's execution, making it unsafe to hoist out of the loop.";A developer is implementing a complex loop that manipulates a lot of variables. ;;;;;
IPCOnUIThread;Runtime;Suboptimal Algorithm, RPC/IPC;No;;;;;;;;;;;;;✅;;✅?;A blocking Binder IPC call occurs on the UI thread;NA;Move any blocking Binder or IPC calls off the main/UI thread and execute them on a background thread.;*.java, *.kt;Warning;IPCOnUIThread1.txt;IPCOnUIThread2.txt;The Inter-Process Communication (IPC) call might be known to be extremely fast and effectively non-blocking because it retrieves a simple, cached value from a local service. While technically an IPC call, its real-world performance impact is zero.;A developer needs to access a content provider directly or indirectly via Binder IPC;;;;;
RegexOpOnUIThread;Runtime;Unnecessary Computation;No;;;;;;;;;;;;;✅;;✅?;"A potentially costly operation on a regular expression occurs on the UI thread.
";NA;Move any potentially computationally expensive computitation to a background thread;*.java, *.kt;Warning;RegexOpOnUIThread1.txt;RegexOpOnUIThread2.txt;The regular expression being used could be very simple (e.g., no complex backtracking) and executed on a short, known-size string. In such cases, the operation is guaranteed to be non-blocking and safe to perform on the UI thread.;A developer uses a greedy regular expression to parse lines from a large text;;;;;
ExpensiveExecutionTime;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;;✅;;✅?;This warning indicates that the procedure has non-constant and non-top execution cost. ;https://fbinfer.com/docs/all-issue-types#expensive_execution_time;Eventually optimize the expensive code to reduce computational complexity or improve algorithm efficiency.;*.java, *.kt;Warning;ExpensiveExecutionTime1.txt;ExpensiveExecutionTime2.txt;A method with a high theoretical complexity (e.g., O(n²)) might be flagged as expensive. However, in practice, it may only ever be called with a very small input size N, making its actual execution time negligible and the warning irrelevant.;A developer develops a suboptimal algorithm with non-constant execution time;;;;;
HugeSharedStringConstant;Memory;Data Manipulation;No;;;;;;;;;;;✅;;;;;A large String constant is duplicated across multiple class files. This is likely because a final field is initialized to a String constant, and the Java language mandates that all references to a final field from other classes be inlined into that classfile;;"Either remove the keyword ""final"" from the String constant declaration or to ""reorg"" the declaration to be followed by a static block that performs the  initializion of the string ";*.java, *.kt;Warning;HugeSharedStringConstant1.txt;HugeSharedStringConstant2.txt;The inlining of a final static string constant might be the desired behavior for performance reasons, as it replaces a field lookup with a direct value at compile time, trading larger class files for faster execution.;A developer defines a huge string as final and shares it across several classes;;;;;
ExplicitGarbageCollection;Runtime;Suboptimal Algorithm, Code Smell;No;;;;;;;;;;;✅;;;;;Code that explicitly invokes garbage collection. Except for specific use in benchmarking, this is very dubious. In the past, situations where people have explicitly invoked the garbage collector in routines such as close or finalize methods has led to huge performance black holes. Garbage collection can be expensive. Any situation that forces hundreds or thousands of garbage collections will bring the machine to a crawl.;;;*.java, *.kt;Warning;ExplicitGarbageCollection1.txt;ExplicitGarbageCollection2.txt;A call to System.gc() is sometimes used justifiably in benchmarking or testing scenarios to create a consistent memory baseline before running a performance-sensitive test. It should not exist in production code.;A developer is implementing memory-greedy tasks;;;;;
BoxedPrimitiveToString;Memory;Data Manipulation, Unnecessary Computation;No;;;;;;;;;;;✅;;;✅;;A boxed primitive is allocated just to call toString(). It is more effective to just use the static form of toString which takes the primitive value.;https://spotbugs.readthedocs.io/en/stable/bugDescriptions.html#bx-method-allocates-a-boxed-primitive-just-to-call-tostring-dm-boxed-primitive-tostring;use the static method toString instead;*.java, *.kt;Warning;BoxedPrimitiveToString1.txt;BoxedPrimitiveToString2.txt;The code might be operating on a generic Object or Number type, not a specific primitive wrapper. In a generic context, calling the instance method .toString() is the only option. The warning becomes a false positive if this generic code happens to be used with a boxed primitive.;For logging, a developer converts an int score to a string ;;;;;
BoxedPrimitiveForParsing;Memory;Data Manipulation, Unnecessary Computation;No;;;;;;;;;;;✅;;;;;A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.;;Just call the static parseXXX method instead;*.java, *.kt;Warning;BoxedPrimitiveForParsing1.txt;BoxedPrimitiveForParsing2.txt;This pattern can be used to handle a NumberFormatException in a generic way for different numeric types, sometimes leading to more concise error-handling code.;A developer parses a user's age from a string;;;;;
BoxedPrimitiveForCompare;Memory;Data Manipulation, Unnecessary Computation;No;;;;;;;;;;;✅;;;;;A boxed primitive is created just to call compareTo() method. It's more efficient to use static compare method (for double and float since Java 1.4, for other primitive types since Java 7) which works on primitives directly.;;Just call the static compare method instead;*.java, *.kt;Warning;BoxedPrimitiveForCompare1.txt;BoxedPrimitiveForCompare2.txt;The code may be targeting a Java version older than Java 7, where the static Integer.compare(a, b) method did not exist, making new Integer(a).compareTo(b) a necessary pattern.;A developer needs to compare prices when sorting products by price;;;;;
UnboxedAndCorecedForTernaryOperator;Runtime;Data Manipulation;No;;;;;;;;;;;✅;;;;;A wrapped primitive value is unboxed and converted to another primitive type as part of the evaluation of a conditional ternary operator (the b ? e1 : e2 operator). The semantics of Java mandate that if e1 and e2 are wrapped numeric values, the values are unboxed and converted/coerced to their common type (e.g, if e1 is of type Integer and e2 is of type Float, then e1 is unboxed, converted to a floating point value, and boxed);;Use primitive types directly if possible or us explicit type casting or conversion outside the ternary operator;*.java, *.kt;Warning;UnboxedAndCorecedForTernaryOperator1.txt;UnboxedAndCorecedForTernaryOperator2.txt;;A developer decides to use a ternary operator to manipulate Number objects;;;;;
UnboxingImmediatelyReboxed;Runtime;Data Manipulation, Unnecessary Computation;No;;;;;;;;;;;✅;;;;;"A boxed value is unboxed and then immediately reboxed.
";;Eliminate unnecessary unboxing and reboxing;*.java, *.kt;Warning;UnboxingImmediatelyReboxed1.txt;UnboxingImmediatelyReboxed2.txt;This is unavoidable when a value from a collection of boxed primitives (e.g., List<Integer>) is retrieved, modified, and then stored back into the collection.;In a loop, a developer increments a cached Integer value ;;;;;
BoxingImmediatelyUnboxed;Runtime;Data Manipulation, Unnecessary Computation;No;;;;;;;;;;;✅;;;;;A primitive is boxed, and then immediately unboxed. This probably is due to a manual boxing in a place where an unboxed value is required, thus forcing the compiler to immediately undo the work of the boxing;;Eliminate unnecessary boxing and unboxing;*.java, *.kt;;BoxingImmediatelyUnboxed1.txt;BoxingImmediatelyUnboxed2.txt;This could be necessary when interacting with a legacy or poorly designed API that requires a boxed primitive, even if the value is immediately unboxed afterward.;A developer manually boxes a primitive int with new Integer(x) before passing it to a method that requires a primitive int;;;;;
BoxingImmediatelyUnboxedToPerformCoercion;Runtime;Data Manipulation, Unnecessary Computation;No;;;;;;;;;;;✅;;;;;A primitive boxed value constructed and then immediately converted into a different primitive type (e.g., new Double(d).intValue()). ;;Just perform direct primitive coercion (e.g., (int) d).;*.java, *.kt;;BoxingImmediatelyUnboxedToPerformCoercion1.txt;BoxingImmediatelyUnboxedToPerformCoercion2.txt;A developer may be working with a generic Number object and needs to convert it. Using a method like myNumber.doubleValue() is standard practice, even if it involves boxing/unboxing under the hood.;A developer needs to get the integer part of a Double;;;;;
NewForGetClass;Runtime;Unnecessary Computation;No;;;;;;;;;;;✅;;;;;"This method allocates an object just to call getClass() on it, in order to retrieve the Class object for it. It is simpler to just access the .class property of the class.
";;;*.java, *.kt;;NewForGetClass1.txt;NewForGetClass2.txt;In a generic context where the type is erased, creating a new instance might be the only way to get access to its Class object if T.class is not available.;A developer needs to obtain a class object for logging purposes ;;;;;
NextIntViaNextDouble;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;✅;;;;; Use the nextInt method of Random rather than nextDouble to generate a random integer;;;*.java, *.kt;;NextIntViaNextDouble1.txt;NextIntViaNextDouble2.txt;The pattern (int)(random.nextDouble() * n) might be used intentionally to achieve a specific non-uniform statistical distribution that random.nextInt(n) does not provide.;A developer needs a  random item from an array of 10 items;;;;;
UnusedField;Memory;Code Smell, Unnecessary Computation;No;;;;;;;;;;;✅;;;;;"If the field is never used, consider removing it from the class.
";;;*.java, *.kt;;UnusedField1.txt;UnusedField2.txt;The field may be used via reflection by a serialization library (like Gson or Jackson), a dependency injection framework, or for data binding. Static analysis tools often cannot detect reflective usage.;A developer adds a boolean isDebug flag for testing;;;;;
UnreadField;Memory;Code Smell;No;;;;;;;;;;;✅;;;;;If the field is never read, consider removing it from the class.;;;*.java, *.kt;;UnreadField1.txt;UnreadField2.txt;Similar to UnusedField, the field might be set but only ever read by an external system, such as a debugging tool or a testing framework that inspects the object's state via reflection.;A developer sets an isModified flag to true whenever data changes;;;;;
UncalledPrivateMethod;Memory;Code Smell;No;;;;;;;;;;;✅;;;;;When a private method is never called. Although it is possible that the method will be invoked through reflection, it is more likely that the method is never used, and should be removed.;;;*.java, *.kt;;UncalledPrivateMethod1.txt;UncalledPrivateMethod2.txt;The private method might be called via reflection (e.g., by a testing framework) or its removal may be pending a larger refactoring.;A developer is refactoring a validation check into a separate utility class that has several private methods;;;;;
UseStringBufferConcatenation;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;;;;;;;✅;;;;;The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.;https://spotbugs.readthedocs.io/en/stable/bugDescriptions.html#sbsc-method-concatenates-strings-using-in-a-loop-sbsc-use-stringbuffer-concatenation;Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 5) explicitly.;*.java, *.kt;;UseStringBufferConcatenation1.txt;UseStringBufferConcatenation2.txt;Modern Java compilers are highly effective at optimizing string concatenation. When the += operator is used inside a loop, the compiler often automatically converts the code to use an internal StringBuilder behind the scenes. Therefore, the generated bytecode can be just as performant as manually writing the StringBuilder code, making this warning a false positive on modern development platforms;A developer needs to concatenate a string;;;;;
ElementsGetLengthInLoop;Runtime;Data Access, Unnecessary Computation;No;;;;;;;;;;;✅;;✅;;;The method calls NodeList.getLength() inside the loop and NodeList was produced by getElementsByTagName call. This NodeList doesn't store its length, but computes it every time in not very optimal way. Consider storing the length to the variable before the loop.;;Consider storing the length to the variable before the loop.;*.java, *.kt;;ElementsGetLengthInLoop1.txt;ElementsGetLengthInLoop2.txt;If the NodeList can be modified by another thread while the loop is executing, caching its length would be a bug. Calling getLength() in each iteration ensures the loop is operating on the most up-to-date information.;A developer iterates through an XML NodeList;;;;;
PrepareStatementInLoop;Runtime;Data Access, Unnecessary Computation;No;;;;;;;;;;;✅;;;;;The method calls Connection.prepareStatement inside the loop passing the constant arguments. If the PreparedStatement should be executed several times there's no reason to recreate it for each loop iteration. Move this call outside the loop.;;;*.java, *.kt;;PrepareStatementInLoop1.txt;PrepareStatementInLoop2.txt;The SQL query string itself might be dynamically generated within each iteration of the loop, making it impossible to create a single PreparedStatement outside the loop.;A developer needs to insert a batch of records into a database;;;;;
PatternCompileInLoop;Runtime;Unnecessary Computation;No;;;;;;;;;;;✅;;;;;The method calls Pattern.compile inside the loop passing the constant arguments. If the Pattern should be used several times there's no reason to compile it for each loop iteration. Move this call outside the loop or even into static final field.;;;*.java, *.kt;;PatternCompileInLoop1.txt;PatternCompileInLoop2.txt;The regular expression pattern itself might be dynamically generated within each iteration, making it impossible to compile it outside the loop.;A developer needs to match a string to a regular expression in a loop;;;;;
InefficientLastIndexOf;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;;;;;;;✅;;;;;"Th4 code passes a constant string of length 1 to String.lastIndexOf(). It is more efficient to use the integer implementations of String.lastIndexOf(). f. e. call myString.lastIndexOf('.') instead of myString.lastIndexOf(""."")";;;*.java, *.kt;;InefficientLastIndexOf1.txt;InefficientLastIndexOf2.txt;The code may be written to handle a String variable that could contain multiple characters, even if it happens to hold a single character in a specific instance. Using lastIndexOf(String) is more robust for the general case.;A developer needs to get a file extension from a filename (String) using lastIndexOf;;;;;
UnnecessaryMath;Runtime;Unnecessary Computation, Suboptimal Algorithm;No;;;;;;;;;;;✅;;;;;This method uses a static method from java.lang.Math on a constant value. This method's result in this case, can be determined statically, and is faster and sometimes more accurate to just use the constant;https://spotbugs.readthedocs.io/en/stable/bugDescriptions.html#um-method-calls-static-math-class-method-on-a-constant-value-um-unnecessary-math;Use  constant values instead;*.java, *.kt;;UnnecessaryMath1.txt;UnnecessaryMath2.txt;A calculation like Math.sqrt(4.0) might be left in the code intentionally for clarity, showing the origin of the value (e.g., it was derived from a formula where the input was 4.0), even though it could be replaced with the constant 2.0.;A developer needs to perform math calculations for a reduced set of possible values;;;;;
BloatedSynchronizedBlock;Runtime;Concurrency;No;;;;;;;;;;;;✅;;;;This method implements a synchronized block, but the code found at the beginning of this block only accesses local variables, and not member variables or this. For better performance, move the code that accesses local variables only above the synchronized block, and leave the synchronized block only for field accesses, or access to this.;;Refactor synchronized block;*.java, *.kt;;BloatedSynchronizedBlock1.txt;BloatedSynchronizedBlock2.txt;The operations on local variables inside the synchronized block might be computationally trivial, and moving them out would make the code logic harder to follow for no tangible performance benefit.;A developer uses a synchronized block while managing a lot of variables and operations ;;;;;
DubiousListCollection;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;This class defines a field based on java.util.List, but uses it to some extent like a Set. Since lookup type operations are performed using a linear search for Lists, the performance for large Lists will be poor. If the list is known to only contain a small number of items (3, 4, etc), then it doesn't matter. Otherwise, consider changing this field's implementation to a set-based one. If order of iteration is important to maintain insert order, perhaps consider a LinkedHashSet.;;;*.java, *.kt;;DubiousListCollection1.txt;DubiousListCollection2.txt;The developer may intentionally use a List to preserve insertion order and allow duplicates, while accepting the performance cost of occasional contains() checks as a trade-off.;A developer needs to To check for the existence of a user ID in a large list of moderators;;;;;
DubiousSetofCollections;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;When a method creates a set that contains other collections, or a Map whose keySet is another collection. As collections tend to calculate hashCode, equals, and compareTo by iterating the contents of the collection, this can perform poorly. In addition, when a set is used, you typically are using it to do 'contains', or 'find' type functionality, which seems dubious when done on a collection. Finally, as a collection is often modified, problems will occur if the collection is contained in a set, because the hashCode, equals or compareTo values will change while the collection is in the set. If you wish to maintain a collection of collections, it is probably better to use a List as the outer collection.;;;*.java, *.kt;;DubiousSetofCollections1.txt;DubiousSetofCollections2.txt;This is a valid pattern for storing a set of unique composite items, where each item is itself a collection (e.g., a set of unique permission groups). As long as the inner collections are not modified while in the outer set, the behavior is well-defined.;A developer needs to use a HashSet  to store unique permission sets for each user type;;;;;
ContainsOnCollectedStream;Runtime;Unnecessary Computation, Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;When a method builds a collection using lambda expressions with a collect terminal operation. It then immediately calls the contains() method on it, to see if an item is present. This is sub optimal as the lambda still needs to build the entire collection, iterating the entire source list. It is better to use anyMatch() to short circuit the building of the collection.;;;*.java, *.kt;;ContainsOnCollectedStream1.txt;ContainsOnCollectedStream2.txt;The code may need the entire collected List for subsequent operations. The contains check is just one of several operations performed on the fully realized list after it has been collected.;A developer checks if a product is in stock by streaming;;;;;
AvoidSizeOnCollectedStream;Runtime;Unnecessary Computation, Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;When a  methods builds a collection using lambda expressions with a collect terminal operation. It then immediately calls the size() method on it, to get a count of items. This is sub optimal as the lambda still needs to build the entire collection, iterating the entire source list. It is better to use count() predicate to short circuit the building of the collection. If you were using a Set, then also add the distinct() predicate.;;;*.java, *.kt;;AvoidSizeOnCollectedStream1.txt;AvoidSizeOnCollectedStream2.txt;;To count the number of active users, a developer streams, filters them and then needs to calcule the size of the filtered set;;;;;
UseFindFirst;Runtime;Unnecessary Computation, Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;Use of streams data into a List just to call get(0) to get the first item. You can just use findFirst() to short circuit the processing of the stream.;;;*.java, *.kt;;UseFindFirst1.txt;UseFindFirst2.txt;The developer might intentionally want to collect all stream elements into a list for caching or debugging purposes first, and then retrieve the first element from that collected list.;A developer uses streams to get the first premium user;;;;;
ExecutorNotShuttingDown;Memory;Resource Management;No;;;;;;;;;;;;✅;;;;Most ExecutorService objects must be explicitly shut down, otherwise their internal threads can prevent the JVM from ever shutting down, even when everything else has stopped.;;;*.java, *.kt;;ExecutorNotShuttingDown1.txt;ExecutorNotShuttingDown2.txt;The ExecutorService might be a singleton instance that is intended to live for the entire application lifecycle and execute background tasks throughout. Such an executor is not meant to be shut down.; developer creates a temporary ExecutorService in a method to run a task;;;;;
DoubleBufferCopy;Runtime;Data Access, Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;When a mehtod copies data from input to output using streams or reader/writers using a well known copy method, from java.nio, commons-io, springframework, guava or poi. These methods are efficient in that they copy these files using buffers. However, this method is also buffering the streams, causing a double buffering to occur. So data first goes to one buffer, then is copied to another buffer, before making it to the destination (or vice-versa). This just causes the copy operation to be inefficient both from a time perspective and a memory allocation one. When using these copy methods, do not pass buffered streams/readers/writers.;;;*.java, *.kt;;DoubleBufferCopy1.txt;DoubleBufferCopy2.txt;The developer may not have control over one of the two buffering layers. For example, an API might require a BufferedInputStream, and the copy utility being used also happens to perform its own buffering.;A developer is neeeds buffering while reading files with FileInputStream ;;;;;
ListIndexIterating;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;Using an Iterator can perform better for certain List implementations (like LinkedList).;;;*.java, *.kt;;ListIndexIterating1.txt;ListIndexIterating2.txt;The code may need to iterate a LinkedList backward or skip elements based on their index. For such access patterns, using a for loop with get(i) can be more straightforward than using a ListIterator.;A developer needs to  iterate a LinkedList;;;;;
LogToStringParameter;Runtime;Unnecessary Computation, API Misuse;No;;;;;;;;;;;;✅;;;;When a method uses parameterized logging to avoid the cost of string concatenation in the case that the log level does not meet the needed level. However, one or more of the parameters passed to the logging method uses .toString() to present a String representation for the parameter. This is unneeded as the logger will do this for you, and because it is explicitly done, will always be called even if the log statement is not actually written. Also, by dropping the '.toString()' you may avoid unnecessary NPEs. Just pass the variable as a parameter instead.;;;*.java, *.kt;;LogToStringParameter1.txt;LogToStringParameter2.txt;The object's toString() method might perform a lazy, expensive calculation. The developer may want to execute it at a precise moment, even if the log message is ultimately discarded.;A developer logs a user object with a custom message;;;;;
LogAppendedStringInFormat;Runtime;Data Manipulation, API Misuse;No;;;;;;;;;;;;✅;;;;When a  method uses an SLF4J or Log4j2 logger to log a string, where the first (format) string is created using concatenation. You should use {} markers to inject dynamic content into the string, so that String building is delayed until the actual log string is needed. If the log level is high enough that this log statement isn't used, then the appends will never be executed.;;;*.java, *.kt;;LogAppendedStringInFormat1.txt;LogAppendedStringInFormat2.txt;The concatenated string might be used for something else besides logging (e.g., displaying in a UI Toast), so it must be created anyway. It is then passed to the logger for convenience.;A developer logs a user object with a custom message and needs to concatenate strings for that;;;;;
LocalSynchronizedCollection;Runtime;Concurrency, Unnecessary Computation;No;;;;;;;;;;;;✅;;;;A  method creates a synchronized collection and stores the reference to it in a local variable. As local variables are by definition thread-safe, it seems questionable that this collection needs to be synchronized.;;;*.java, *.kt;;LocalSynchronizedCollection1.txt;LocalSynchronizedCollection2.txt;The local collection, while created in a single thread, might be passed to other threads for processing (e.g., submitted to an ExecutorService), in which case the synchronization is necessary.;A developer needs to manipulate a local ArrayList In a single-threaded method;;;;;
UseSingletonList;Runtime;Suboptimal Algorithm, API Misuse;No;;;;;;;;;;;;✅;;;;A  method builds a list using Arrays.asList(foo), passing in a single element. Arrays.asList needs to first create an array from this one element, and then build a List that wraps this array. It is simpler to use Collections.singletonList(foo), which does not create the array, and produces a far simpler instance of List. Since both of these arrays are immutable (from the List's point of view) they are equivalent from a usage standpoint. There is one difference between Array.asList and Collections.singletonList that you should be mindful of. The rarely used set(index, value) method is allowed to be used with a List created by Array.asList, but not with Collections.singletonList. So if you do use the set(index, value) method continue using Arrays.asList.;;;*.java, *.kt;;UseSingletonList1.txt;UseSingletonList2.txt;Arrays.asList() returns a list where the set() method can be called. If the code relies on this ability, it is the correct choice over the truly immutable Collections.singletonList().;A developer needs to return a list containing a single literal string;;;;;
RunFinalization;Runtime;Code Smell, API Misuse;No;;;;;;;;;;;;✅;;;;"Manually triggering finalization can result in serious performance problems and may be masking resource cleanup bugs. Only the garbage collector, not application code, should be concerned with finalization.
";;;*.java, *.kt;;RunFinalization1.txt;RunFinalization2.txt;This is almost never justified in production code but might be used in a specific testing or benchmarking scenario to attempt to force the cleanup of native resources to check for leaks.;Concerned about memory, a developer whants to improve memory consumption after running an heavy task;;;;;
CallingSizeOnSubContainer;Memory;Unnecessary Computation;No;;;;;;;;;;;;✅;;;;A method calls size on the keySet(), entrySet() or values() collections of a Map. These sub collections will have the same size as the base Map and so it is just simpler to call size on that Map. Calling size() on one of these sub collections will causes unnecessary allocations to occur.;;;*.java, *.kt;;CallingSizeOnSubContainer1.txt;CallingSizeOnSubContainer2.txt;A developer might have a reference to a map's keySet or values collection but not to the original map itself. In that context, calling size() on the sub-collection is the most direct approach.;A developer checks if a map is empty when iterating a map through keySet();;;;;
ContainsKeyBeforeGet;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;A method checks for the presence of a key in a map using containsKey(), before attempting to fetch the value of the key using get(). This equates to doing two map lookups in a row. It is much simpler to just fetch the value with get, and checking for non null instead.;;;*.java, *.kt;;ContainsKeyBeforeGet1.txt;ContainsKeyBeforeGet2.txt;If a map can contain null values, map.get(key) returning null is ambiguous (key absent vs. key present with null value). Calling containsKey() first is the only way to distinguish these cases.;A developer needs to get a value from a Map if exists;;;;;
GetBeforeRemove;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;A method fetches the value of an entry in a map using get(K k), and then follows it up with a remove(K k). Since a remove() also returns the value, there is no point for doing the get, and just causes two map lookups to occur when it can be done with just one.;;;*.java, *.kt;;GetBeforeRemove1.txt;GetBeforeRemove2.txt;The code may need to perform some logic or validation on the value obtained from get() before deciding whether to remove it, making the two-step process intentional.;A developer needs to remove a value from a Map if exists and return it ;;;;;
NeedlessInstanceRetrieval;Runtime;Unnecessary Computation;No;;;;;;;;;;;;✅;;;;A method calls a method to load a reference to an object, and then only uses it to load a static member of that instance's class. It is simpler and more performant to just load the static field from the class itself.;;;*.java, *.kt;;NeedlessInstanceRetrieval1.txt;NeedlessInstanceRetrieval2.txt;The code might be generated by a tool that follows a simple but inefficient pattern, and manual editing is not feasible.;A developer needs to get a static constant ;;;;;
NeedlessMemberCollectionSynchronization;Runtime;Unnecessary Computation, Concurrency;No;;;;;;;;;;;;✅;;;;"A class defines a private collection member as synchronized. It appears, however, that this collection is only modified in a static initializer, or constructor. As these two areas are guaranteed to be thread safe, defining this collection as synchronized is unnecessary and a potential performance bottleneck.
";;;*.java, *.kt;;NeedlessMemberCollectionSynchronization1.txt;NeedlessMemberCollectionSynchronization2.txt;The class might be designed for extension, and subclasses could introduce multithreaded access. The synchronization in the base class is a defensive measure to ensure thread safety for all subclasses.;A developer declares a synchronizedSet and populates it in the constructor;;;;;
OptionalPrimitiveVariantPreferred;Runtime;Data Manipulation, Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;"A method creates an Optional object to hold an int, double or long. In these cases it is more natural to use the Optional variants OptionalInt, OptionalDouble and OptionalLong.
";;;*.java, *.kt;;OptionalPrimitiveVariantPreferred1.txt;OptionalPrimitiveVariantPreferred2.txt;The code may need to interoperate with a generic API that works with Optional<T> and cannot be changed. It must return an Optional<Integer> to satisfy the generic interface.;A developer wants to use Optional*<> primitives to return user's age;;;;;
OptionalIssuesUsesImmediateExecution;Runtime;Unnecessary Computation;No;;;;;;;;;;;;✅;;;;A method uses the Optional.orElse() method passing in some code that will execute immediately, whether or not the else case of the Optional is needed. This may cause incorrect side effects to happen, or at the minimum, code to execute for no reason. It would be better to use Optional.orElseGet();;;*.java, *.kt;;OptionalIssuesUsesImmediateExecution1.txt;OptionalIssuesUsesImmediateExecution2.txt;The method called in orElse() may be a simple, non-allocating getter that is cheap to execute. The developer may choose the more concise orElse() for readability when the performance cost is zero.;A developer provides a default value to an optional;;;;;
InstanceBasedThreadLocal;Memory;Concurrency;No;;;;;;;;;;;;✅;;;;When a ThreadLocal field is defined as being instance based (not static). As all ThreadLocal variables describe permanent reachability roots so far as the garbage collector is concerned, these variables will never be reclaimed (so long as the Thread lives). Since this ThreadLocal is instanced, you potentially will be creating many non-reclaimable variables, even after the owning instance has been reclaimed. It is almost a certainty that you want to use static based ThreadLocal variables.;;;*.java, *.kt;;InstanceBasedThreadLocal1.txt;InstanceBasedThreadLocal2.txt;This is rare, but in a framework where instances of a class are guaranteed to be managed one-per-thread, an instance-based ThreadLocal is functionally equivalent to a static one within that specific context and would not cause a leak.;A developer needs to declare a ThreadLocal field in a request handler class;;;;;
PossibleMemoryBloat;Memory;Resource Management;No;;;;;;;;;;;;✅;;;;A class defines static fields that are Collections, StringBuffers, or StringBuilders that do not appear to have any way to clear or reduce their size. That is, a collection is defined and has method calls like {add(), append(), offer(), put(), ...} with no method calls to removal methods like {clear(), delete(), pop(), remove(), ...} This means that the collection in question can only ever increase in size, which is a potential cause of memory bloat.;;;*.java, *.kt;;PossibleMemoryBloat1.txt;PossibleMemoryBloat2.txt;The static collection might be a cache that is intended to grow and store data for the entire application's lifecycle. If the total number of items is bounded and known to be a reasonable size, this is not a memory leak but the intended design.;A developer creates a static final Map as an in-memory cache;;;;;
PreSizeCollections;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;This method allocates a collection using the default constructor even though it is known a priori (or at least can be reasonably guessed) how many items are going to be placed in the collection, and thus needlessly causes intermediate reallocations of the collection. You can use the constructor that takes an initial size and that will be much better, but due to the loadFactor of Maps and Sets, even this will not be a correct estimate.;;;*.java, *.kt;;PreSizeCollections1.txt;PreSizeCollections2.txt;The initial size is just a best-effort estimate. The developer provides a common initial capacity to avoid reallocations in the most frequent scenarios, while accepting that reallocations may still occur in others.;A developer needs to copy a 10,000-element list into a new ArrayList;;;;;
SubOptimalCollectionSizing;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;This method allocates a collection using the a constructor that takes a size parameter. However, because Maps and Sets have a loading factor, passing in the exact size you want is an incorrect way to presize the collection, and may still cause reallocations. Since you are using Guava, it is better to use  Maps.newHashMapWithExpectedSize(c.size()  or Sets.newHashSetWithExpectedsize(c.size())  as this method calculates the correct size taking into account the loading factor. Alternatively, if you know that the collection will not grow beyond the initial size, you can specify a load factor of 1.0F in the constructor.;;;*.java, *.kt;;SubOptimalCollectionSizing1.txt;SubOptimalCollectionSizing2.txt;;A developer initializes a HashSet that will hold exactly 100 items;;;;;
StaticArrayCreatedInMethod;Runtime;Unnecessary Computation;No;;;;;;;;;;;;✅;;;;A  method creates an array initialized by constants. Each time this method is called this array will be recreated. It would be more performant to define the array as a static field of the class instead.;The method may be a temporary, private helper where defining the constant array locally enhances readability and avoids polluting the class's namespace. The performance impact is negligible if the method is not called frequently.;;*.java, *.kt;;StaticArrayCreatedInMethod1.txt;StaticArrayCreatedInMethod2.txt;;A develper needs a method that returns a constant array of default values ;;;;;
SubOptimalExpressionOrder;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;A method builds a conditional expression, for example, in an if or while statement, where the expressions contain both simple local variable comparisons and comparisons on method calls. The expression orders these so that the method calls come before the simple local variable comparisons. This causes method calls to be executed in conditions when they do not need to be, and thus potentially causes a lot of code to be executed for nothing. By ordering the expressions so that the simple conditions containing local variable conditions are first, you eliminate this waste. This assumes that the method calls do not have side effects. If the methods do have side effects, it is probably a better idea to pull these calls out of the condition and execute them first, assigning a value to a local variable. In this way you give a hint that the call may have side effects.;;;*.java, *.kt;;SubOptimalExpressionOrder1.txt;SubOptimalExpressionOrder2.txt;"The ""expensive"" method call that is checked first might have a required side effect that must be executed regardless of the outcome of the cheaper checks.";A developer needs complex conditional expressions in a if;;;;;
SQLInLoop;Runtime;Data Access, Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;A  method executes SQL queries inside of a loop. This pattern is often inefficient as the number of queries may mushroom in fencepost cases. It is probably more performant to loop over the input and collect the key data needed for the query for all items, and issue one query using an in clause, or similar construct, and then loop over this result set, and fetch all the data at once.;;;*.java, *.kt;;SQLInLoop1.txt;SQLInLoop2.txt;The result of one SQL query inside the loop might be required as input for the next query in the subsequent iteration, making it impossible to batch the queries into a single operation.;A developer needs to fetch data for 100 users from a database;;;;;
ContainsBeforeAdd;Runtime;Unnecessary Computation;No;;;;;;;;;;;;✅;;;;"This method checks to see if an element is not in a set before adding it. This is unnecessary as you can just add the item, and if the item exists, it won't add it, otherwise it will.
";;;*.java, *.kt;;ContainsBeforeAdd1.txt;ContainsBeforeAdd2.txt;If the add operation itself has a significant side effect or cost (e.g., triggering a network call), it is valid to check for the element's presence first to avoid that cost.;A developer needs to add a value to a set that might exist already;;;;;
ContainsBeforeRemove;Runtime;Unnecessary Computation;No;;;;;;;;;;;;✅;;;;"This method checks to see if an element is in a set before removing it. This is unnecessary as you can just remove the item, and if the item exists, it will return true.
";;;*.java, *.kt;;ContainsBeforeRemove1.txt;ContainsBeforeRemove2.txt;"The remove operation may have a side effect that should only occur if the element was actually present (e.g., logging ""User X was removed""). Checking for existence first allows for this conditional logic.";A developer needs to remove a value from a set that might not exist yet;;;;;
TailRecursion;Memory;Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;"This method recursively calls itself as the last statement of the method (Tail Recursion). This method can be easily refactored into a simple loop, which will make it more performant, and reduce the stack size requirements.
";;;*.java, *.kt;;TailRecursion1.txt;TailRecursion2.txt;For some algorithms, particularly those involving tree traversal or functional-style programming, the recursive form is a much clearer and more natural representation of the logic than an iterative loop. The improved readability can be worth the minor performance trade-off. If the maximum recursion depth is known to be small and well within the limits of the stack size, using a recursive implementation might be preferred for its clarity and elegance over a more complex iterative solution.;A developer implements a fibonnacci algorithm ;;;;;
UseAddAll;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;✅;;;;"This method uses a simple for loop to copy the contents of a set, list, map key/value, array or other collection to another collection. It is simpler and more straightforward to just call the addAll method of the destination collection passing in the source collection. In the case that the source is an array, you can use the Arrays.asList method to wrap the array into a collection.
";;;*.java, *.kt;;UseAddAll1.txt;UseAddAll2.txt;The for loop may be transforming or wrapping each element before adding it to the destination collection, a task that addAll cannot perform.;A developer needs to copy one list into another ;;;;;
UseEnumCollections;Runtime;Data Manipulation, Obsolete Solution;No;;;;;;;;;;;;✅;;;;This class uses an ordinary set or map collection and uses an enum class as the key type. It is more performant to use the JDK 1.5 EnumSet or EnumMap classes.;;;*.java, *.kt;;UseEnumCollections1.txt;UseEnumCollections2.txt;The code needs to be compatible with older versions of Java (pre-1.5) where EnumSet and EnumMap did not exist.;A developer needs a Map to store Enum values as key;;;;;
UnjitableMethod;Runtime;Code Smell;No;;;;;;;;;;;;✅;;;;This method is longer than 8000 bytes. By default the JIT will not attempt to compile this method no matter how hot it is, and so this method will always be interpreted. If performance is important, you should consider breaking this method up into smaller chunks. (And it's probably a good idea for readability too!);;;*.java, *.kt;;UnjitableMethod1.txt;UnjitableMethod2.txt;"The method, while long, might be ""cold code"" that is executed very rarely. If it is not on a performance-critical path, the fact that it is not JIT-compiled will have no noticeable impact on the application.";A developer needs to write a very extensive method;;;;;
ArrayPrimitive;Runtime;Data Manipulation;No;;;;;;;;;;;;;;✅;✅;Using `Array<Primitive>` leads to implicit boxing and performance hit. Prefer using Kotlin specialized Array Instances.  Kotlin has specialized arrays to represent primitive types without boxing overhead, such as `IntArray`, `ByteArray` and so on.;https://github.com/detekt/detekt/blob/main/detekt-rules-performance/src/main/kotlin/dev/detekt/rules/performance/ArrayPrimitive.kt;Replace generic Arrays with specialized arrays;*.kt;;ArrayPrimitive1.txt;ArrayPrimitive2.txt;The code may need to interact with a generic Java API that requires an Array<Integer> (an array of objects) and cannot work with a primitive IntArray.; A developer needs an Array to store millions of integers;;;;;
CouldBeSequence;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;;;✅;✅;Long chains of collection operations will have a performance penalty due to a new list being created for each call. Consider using sequences instead;https://github.com/detekt/detekt/blob/main/detekt-rules-performance/src/main/kotlin/dev/detekt/rules/performance/CouldBeSequence.kt;Use sequences instead;*.kt;;CouldBeSequence1.txt;CouldBeSequence2.txt;If the initial collection is known to be very small, the overhead of creating a Sequence object and its iterator can be greater than the cost of creating intermediate lists for each collection operation.;A developer needs to perform  multiple map and filter operations on a large collection;;;;;
ForEachOnRange;Runtime;Suboptimal Algorithm;No;;;;;;;;;;;;;;✅;✅;Using the forEach method on ranges has a heavy performance cost. Prefer using simple for loops.  Benchmarks have shown that using forEach on a range can have a huge performance cost in comparison to  simple for loops. Hence, in most contexts, a simple for loop should be used instead.;https://github.com/detekt/detekt/blob/main/detekt-rules-performance/src/main/kotlin/dev/detekt/rules/performance/ForEachOnRange.kt;To solve this code smell, the forEach usage over an range should be replaced by a for loop;*.kt;;ForEachOnRange1.txt;ForEachOnRange2.txt;A developer might use forEach on a range to maintain a consistent, fluent style within a chain of other collection operations. The loss of performance may be an acceptable trade-off for code readability in non-critical sections.;A developer needs to perform a loop form 1 to 1 million;;;;;
SpreadOperator;Memory;Data Manipulation;No;;;;;;;;;;;;;;✅;✅;In most cases using a spread operator causes a full copy of the array to be created before calling a method.  This has a very high performance penalty.  The Kotlin compiler since v1.1.60 has an optimization that skips the array copy when an array constructor function is used to create the arguments that are passed to the vararg parameter. This case will not be flagged by the rule since it doesn't suffer the performance penalty of an array copy.;;Refactor in order to the array copy be skipped for the usage of the spread operator;*.kt;;SpreadOperator1.txt;SpreadOperator2.txt;The spread operator creates a copy of the array. This might be the desired behavior if the developer wants to prevent the called function from modifying the original array (defensive copying).;a developer needs to write a function to process a large array and already has a function to do that in the same class that receives an unlimited number of arguments;;;;;
UnnecessaryPartOfBinaryExpression;Runtime;Code Smell;No;;;;;;;;;;;;;;✅;✅;when a method uses unnecessary binary expressions, including those in `if` and `when` conditions, as well as all predicates.;https://github.com/detekt/detekt/blob/main/detekt-rules-performance/src/main/kotlin/dev/detekt/rules/performance/UnnecessaryPartOfBinaryExpression.kt;Remove unncessary part of binary expression;*.java, *.kt;;UnnecessaryPartOfBinaryExpression1.txt;UnnecessaryPartOfBinaryExpression2.txt;The seemingly unnecessary part of a boolean expression might be left in the code intentionally for readability or as a form of documentation, making the logical flow explicit even if it could be simplified.;A developer writes if with fixed constatn values;;;;;
UnnecessaryTypeCasting;Runtime;Code Smell, Unnecessary Computation;No;;;;;;;;;;;;;;✅;✅;Cast in a unnecessary type casting. Cases like this can be replaced with type checking for performance reasons.;https://github.com/detekt/detekt/blob/main/detekt-rules-performance/src/main/kotlin/dev/detekt/rules/performance/UnnecessaryTypeCasting.kt;Use type checking instead.;*.java, *.kt;;UnnecessaryTypeCasting1.txt;UnnecessaryTypeCasting2.txt;An explicit cast, while seemingly redundant, might be necessary to help the compiler resolve an ambiguous method overload, where it cannot infer the correct type without the developer's guidance.;A developer needs to get the lenght of a string after a if (obj is String) block;;;;;
